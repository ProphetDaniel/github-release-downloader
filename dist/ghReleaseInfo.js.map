{"version":3,"sources":["webpack://ghReleaseInfo/webpack/universalModuleDefinition","webpack://ghReleaseInfo/webpack/bootstrap","webpack://ghReleaseInfo/./node_modules/tiny-emitter/index.js","webpack://ghReleaseInfo/./node_modules/typed-function/typed-function.js","webpack://ghReleaseInfo/./node_modules/xhr2/lib/browser.js","webpack://ghReleaseInfo/./src/core.js","webpack://ghReleaseInfo/./src/index.js","webpack://ghReleaseInfo/./src/lib/core/core.js","webpack://ghReleaseInfo/./src/lib/core/function/config.js","webpack://ghReleaseInfo/./src/lib/core/function/import.js","webpack://ghReleaseInfo/./src/lib/core/typed.js","webpack://ghReleaseInfo/./src/lib/error/ArgumentsError.js","webpack://ghReleaseInfo/./src/lib/error/DimensionError.js","webpack://ghReleaseInfo/./src/lib/error/IndexError.js","webpack://ghReleaseInfo/./src/lib/error/index.js","webpack://ghReleaseInfo/./src/lib/function/clone.js","webpack://ghReleaseInfo/./src/lib/function/get.js","webpack://ghReleaseInfo/./src/lib/function/index.js","webpack://ghReleaseInfo/./src/lib/index.js","webpack://ghReleaseInfo/./src/lib/json/index.js","webpack://ghReleaseInfo/./src/lib/json/reviver.js","webpack://ghReleaseInfo/./src/lib/utils/bignumber/isBigNumber.js","webpack://ghReleaseInfo/./src/lib/utils/collection/isMatrix.js","webpack://ghReleaseInfo/./src/lib/utils/emitter.js","webpack://ghReleaseInfo/./src/lib/utils/number.js","webpack://ghReleaseInfo/./src/lib/utils/object.js"],"names":["module","exports","require","core","create","config","ghReleaseInfo","isFactory","typedFactory","emitter","importFactory","configFactory","options","Object","Error","factories","instances","math","mixin","type","expression","transform","mathWithTransform","typed","_config","epsilon","matrix","number","precision","predictable","randomSeed","load","factory","index","indexOf","instance","push","object","MATRIX","NUMBER","prev","map","clone","validateOption","deepExtend","curr","changes","emit","contains","array","item","findIndex","i","toLowerCase","name","values","undefined","console","warn","JSON","stringify","join","lazy","traverse","ArgumentsError","math_import","num","arguments","length","_importFactory","Array","isArray","forEach","entry","hasOwnProperty","value","isSupportedType","_import","silent","TypeError","wrap","_wrap","isTypedFunction","override","signatures","_importTransform","resolver","allowedInExpressions","fn","wrapper","args","len","arg","valueOf","apply","existingTransform","namespace","path","existing","factoryAllowedInExpressions","isUnit","isComplex","isBigNumber","isFraction","isMatrix","unsafe","typedFunction","digits","createTyped","isNumber","x","Complex","Fraction","constructor","prototype","isString","isDenseMatrix","isSparseMatrix","isRange","isIndex","isBoolean","isResultSet","isHelp","isFunction","isDate","Date","isRegExp","RegExp","isObject","isNull","isUndefined","isAccessorNode","isNode","isArrayNode","isAssignmentNode","isBlockNode","isConditionalNode","isConstantNode","isFunctionAssignmentNode","isFunctionNode","isIndexNode","isObjectNode","isOperatorNode","isParenthesisNode","isRangeNode","isSymbolNode","isChain","types","test","conversions","from","to","convert","BigNumber","toNumber","f","n","Number","isNaN","err","DenseMatrix","count","min","max","SyntaxError","message","stack","isArgumentsError","DimensionError","actual","expected","relation","RangeError","isDimensionError","IndexError","isIndexError","toTex","XMLHttpRequest","loadJSON","success","error","xhr","onreadystatechange","readyState","DONE","status","parse","responseText","open","send","GetLatestGitHubReleaseInfo","repo","Promise","release","tuppleList","IsRelease","url","endsWith","oneHour","oneDay","assets","filter","asset","browser_download_url","casset","dateDiff","updated_at","timeAgo","toFixed","download_count","returnStructVar","releaseName","downloadList","resolve","URIError","get","reviver","key","mathjs","node","fromJSON","Emitter","obj","on","bind","off","once","isInteger","isFinite","Math","round","sign","format","Infinity","notation","toExponential","toEngineering","exponential","lower","upper","fixedOptions","assign","lowerExp","log","LN10","upperExp","toPrecision","replace","e","splitNumber","match","String","exponent","parseFloat","dot","coefficients","zeros","split","d","parseInt","rounded","roundDigits","c","newExp","significandsDiff","abs","concat","expDiff","decimalIdx","decimals","slice","decimalVal","str","toString","splitValue","p","pp","splice","first","shift","unshift","removed","pop","arr","DBL_EPSILON","EPSILON","nearlyEqual","y","diff","Boolean","callback","extend","a","b","prop","deepEqual","canDefineProperty","defineProperty","_uninitialized","_value","set","configurable","enumerable","names","property","call"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA,WAAW,SAAS;AACpB;AACA;;AAEA;AACA,GAAG;;AAEH;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA,GAAG,QAQH;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO,wCAAwC,+BAA+B,EAAE;AAChF,OAAO,wCAAwC,+BAA+B,EAAE;AAChF,OAAO,wCAAwC,gCAAgC,EAAE;AACjF,OAAO,wCAAwC,gCAAgC,EAAE;AACjF,OAAO,yCAAyC;AAChD,OAAO,wCAAwC,2BAA2B,EAAE;AAC5E,OAAO,wCAAwC,6BAA6B,EAAE;AAC9E,OAAO;AACP;AACA,QAAQ;AACR,OAAO,wCAAwC,oBAAoB,EAAE;AACrE,OAAO,wCAAwC,yBAAyB;AACxE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,kBAAkB;AACjC;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,gBAAgB;AAC/B,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,gBAAgB;AAC/B,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,KAAK;AACpB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,eAAe,YAAY;AAC3B,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,SAAS;AACxB,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA,qBAAqB,QAAQ;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wEAAwE,mCAAmC;AAC3G,wEAAwE,mCAAmC;AAC3G,wEAAwE,mCAAmC;AAC3G,wEAAwE,mCAAmC;AAC3G,wEAAwE,mCAAmC;AAC3G,wEAAwE,mCAAmC;;AAE3G;AACA;;AAEA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,+BAA+B;AAC9C,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,EAAE;AACjB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,gBAAgB;AAChB;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AA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","file":"ghReleaseInfo.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ghReleaseInfo\"] = factory();\n\telse\n\t\troot[\"ghReleaseInfo\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","function E () {\n  // Keep this empty so it's easier to inherit from\n  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n\nE.prototype = {\n  on: function (name, callback, ctx) {\n    var e = this.e || (this.e = {});\n\n    (e[name] || (e[name] = [])).push({\n      fn: callback,\n      ctx: ctx\n    });\n\n    return this;\n  },\n\n  once: function (name, callback, ctx) {\n    var self = this;\n    function listener () {\n      self.off(name, listener);\n      callback.apply(ctx, arguments);\n    };\n\n    listener._ = callback\n    return this.on(name, listener, ctx);\n  },\n\n  emit: function (name) {\n    var data = [].slice.call(arguments, 1);\n    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n    var i = 0;\n    var len = evtArr.length;\n\n    for (i; i < len; i++) {\n      evtArr[i].fn.apply(evtArr[i].ctx, data);\n    }\n\n    return this;\n  },\n\n  off: function (name, callback) {\n    var e = this.e || (this.e = {});\n    var evts = e[name];\n    var liveEvents = [];\n\n    if (evts && callback) {\n      for (var i = 0, len = evts.length; i < len; i++) {\n        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\n          liveEvents.push(evts[i]);\n      }\n    }\n\n    // Remove event from queue to prevent memory leak\n    // Suggested by https://github.com/lazd\n    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n    (liveEvents.length)\n      ? e[name] = liveEvents\n      : delete e[name];\n\n    return this;\n  }\n};\n\nmodule.exports = E;\n","/**\n * typed-function\n *\n * Type checking for JavaScript functions\n *\n * https://github.com/josdejong/typed-function\n */\n'use strict';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // OldNode. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like OldNode.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.typed = factory();\n  }\n}(this, function () {\n\n  function ok () {\n    return true;\n  }\n\n  function notOk () {\n    return false;\n  }\n\n  function undef () {\n    return undefined;\n  }\n\n  /**\n   * @typedef {{\n   *   params: Param[],\n   *   fn: function\n   * }} Signature\n   *\n   * @typedef {{\n   *   types: Type[],\n   *   restParam: boolean\n   * }} Param\n   *\n   * @typedef {{\n   *   name: string,\n   *   typeIndex: number,\n   *   test: function,\n   *   conversion?: ConversionDef,\n   *   conversionIndex: number,\n   * }} Type\n   *\n   * @typedef {{\n   *   from: string,\n   *   to: string,\n   *   convert: function (*) : *\n   * }} ConversionDef\n   *\n   * @typedef {{\n   *   name: string,\n   *   test: function(*) : boolean\n   * }} TypeDef\n   */\n\n  // create a new instance of typed-function\n  function create () {\n    // data type tests\n    var _types = [\n      { name: 'number',    test: function (x) { return typeof x === 'number' } },\n      { name: 'string',    test: function (x) { return typeof x === 'string' } },\n      { name: 'boolean',   test: function (x) { return typeof x === 'boolean' } },\n      { name: 'Function',  test: function (x) { return typeof x === 'function'} },\n      { name: 'Array',     test: Array.isArray },\n      { name: 'Date',      test: function (x) { return x instanceof Date } },\n      { name: 'RegExp',    test: function (x) { return x instanceof RegExp } },\n      { name: 'Object',    test: function (x) {\n        return typeof x === 'object' && x.constructor === Object\n      }},\n      { name: 'null',      test: function (x) { return x === null } },\n      { name: 'undefined', test: function (x) { return x === undefined } }\n    ];\n\n    var anyType = {\n      name: 'any',\n      test: ok\n    }\n\n    // types which need to be ignored\n    var _ignore = [];\n\n    // type conversions\n    var _conversions = [];\n\n    // This is a temporary object, will be replaced with a typed function at the end\n    var typed = {\n      types: _types,\n      conversions: _conversions,\n      ignore: _ignore\n    };\n\n    /**\n     * Find the test function for a type\n     * @param {String} typeName\n     * @return {TypeDef} Returns the type definition when found,\n     *                    Throws a TypeError otherwise\n     */\n    function findTypeByName (typeName) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.name === typeName;\n      });\n\n      if (entry) {\n        return entry;\n      }\n\n      if (typeName === 'any') { // special baked-in case 'any'\n        return anyType;\n      }\n\n      var hint = findInArray(typed.types, function (entry) {\n        return entry.name.toLowerCase() === typeName.toLowerCase();\n      });\n\n      throw new TypeError('Unknown type \"' + typeName + '\"' +\n          (hint ? ('. Did you mean \"' + hint.name + '\"?') : ''));\n    }\n\n    /**\n     * Find the index of a type definition. Handles special case 'any'\n     * @param {TypeDef} type\n     * @return {number}\n     */\n    function findTypeIndex(type) {\n      if (type === anyType) {\n        return 999;\n      }\n\n      return typed.types.indexOf(type);\n    }\n\n    /**\n     * Find a type that matches a value.\n     * @param {*} value\n     * @return {string} Returns the name of the first type for which\n     *                  the type test matches the value.\n     */\n    function findTypeName(value) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.test(value);\n      });\n\n      if (entry) {\n        return entry.name;\n      }\n\n      throw new TypeError('Value has unknown type. Value: ' + value);\n    }\n\n    /**\n     * Find a specific signature from a (composed) typed function, for example:\n     *\n     *   typed.find(fn, ['number', 'string'])\n     *   typed.find(fn, 'number, string')\n     *\n     * Function find only only works for exact matches.\n     *\n     * @param {Function} fn                   A typed-function\n     * @param {string | string[]} signature   Signature to be found, can be\n     *                                        an array or a comma separated string.\n     * @return {Function}                     Returns the matching signature, or\n     *                                        throws an error when no signature\n     *                                        is found.\n     */\n    function find (fn, signature) {\n      if (!fn.signatures) {\n        throw new TypeError('Function is no typed-function');\n      }\n\n      // normalize input\n      var arr;\n      if (typeof signature === 'string') {\n        arr = signature.split(',');\n        for (var i = 0; i < arr.length; i++) {\n          arr[i] = arr[i].trim();\n        }\n      }\n      else if (Array.isArray(signature)) {\n        arr = signature;\n      }\n      else {\n        throw new TypeError('String array or a comma separated string expected');\n      }\n\n      var str = arr.join(',');\n\n      // find an exact match\n      var match = fn.signatures[str];\n      if (match) {\n        return match;\n      }\n\n      // TODO: extend find to match non-exact signatures\n\n      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');\n    }\n\n    /**\n     * Convert a given value to another data type.\n     * @param {*} value\n     * @param {string} type\n     */\n    function convert (value, type) {\n      var from = findTypeName(value);\n\n      // check conversion is needed\n      if (type === from) {\n        return value;\n      }\n\n      for (var i = 0; i < typed.conversions.length; i++) {\n        var conversion = typed.conversions[i];\n        if (conversion.from === from && conversion.to === type) {\n          return conversion.convert(value);\n        }\n      }\n\n      throw new Error('Cannot convert from ' + from + ' to ' + type);\n    }\n    \n    /**\n     * Stringify parameters in a normalized way\n     * @param {Param[]} params\n     * @return {string}\n     */\n    function stringifyParams (params) {\n      return params\n          .map(function (param) {\n            var typeNames = param.types.map(getTypeName);\n\n            return (param.restParam ? '...' : '') + typeNames.join('|');\n          })\n          .join(',');\n    }\n\n    /**\n     * Parse a parameter, like \"...number | boolean\"\n     * @param {string} param\n     * @param {ConversionDef[]} conversions\n     * @return {Param} param\n     */\n    function parseParam (param, conversions) {\n      var restParam = param.indexOf('...') === 0;\n      var types = (!restParam)\n          ? param\n          : (param.length > 3)\n              ? param.slice(3)\n              : 'any';\n\n      var typeNames = types.split('|').map(trim)\n          .filter(notEmpty)\n          .filter(notIgnore);\n\n      var matchingConversions = filterConversions(conversions, typeNames);\n\n      var exactTypes = typeNames.map(function (typeName) {\n        var type = findTypeByName(typeName);\n\n        return {\n          name: typeName,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: null,\n          conversionIndex: -1\n        };\n      });\n\n      var convertibleTypes = matchingConversions.map(function (conversion) {\n        var type = findTypeByName(conversion.from);\n\n        return {\n          name: conversion.from,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: conversion,\n          conversionIndex: conversions.indexOf(conversion)\n        };\n      });\n\n      return {\n        types: exactTypes.concat(convertibleTypes),\n        restParam: restParam\n      };\n    }\n\n    /**\n     * Parse a signature with comma separated parameters,\n     * like \"number | boolean, ...string\"\n     * @param {string} signature\n     * @param {function} fn\n     * @param {ConversionDef[]} conversions\n     * @return {Signature | null} signature\n     */\n    function parseSignature (signature, fn, conversions) {\n      var params = [];\n\n      if (signature.trim() !== '') {\n        params = signature\n            .split(',')\n            .map(trim)\n            .map(function (param, index, array) {\n              var parsedParam = parseParam(param, conversions);\n\n              if (parsedParam.restParam && (index !== array.length - 1)) {\n                throw new SyntaxError('Unexpected rest parameter \"' + param + '\": ' +\n                    'only allowed for the last parameter');\n              }\n\n              return parsedParam;\n          });\n      }\n\n      if (params.some(isInvalidParam)) {\n        // invalid signature: at least one parameter has no types\n        // (they may have been filtered)\n        return null;\n      }\n\n      return {\n        params: params,\n        fn: fn\n      };\n    }\n\n    /**\n     * Test whether a set of params contains a restParam\n     * @param {Param[]} params\n     * @return {boolean} Returns true when the last parameter is a restParam\n     */\n    function hasRestParam(params) {\n      var param = last(params)\n      return param ? param.restParam : false;\n    }\n\n    /**\n     * Test whether a parameter contains conversions\n     * @param {Param} param\n     * @return {boolean} Returns true when at least one of the parameters\n     *                   contains a conversion.\n     */\n    function hasConversions(param) {\n      return param.types.some(function (type) {\n        return type.conversion != null;\n      });\n    }\n\n    /**\n     * Create a type test for a single parameter, which can have one or multiple\n     * types.\n     * @param {Param} param\n     * @return {function(x: *) : boolean} Returns a test function\n     */\n    function compileTest(param) {\n      if (!param || param.types.length === 0) {\n        // nothing to do\n        return ok;\n      }\n      else if (param.types.length === 1) {\n        return findTypeByName(param.types[0].name).test;\n      }\n      else if (param.types.length === 2) {\n        var test0 = findTypeByName(param.types[0].name).test;\n        var test1 = findTypeByName(param.types[1].name).test;\n        return function or(x) {\n          return test0(x) || test1(x);\n        }\n      }\n      else { // param.types.length > 2\n        var tests = param.types.map(function (type) {\n          return findTypeByName(type.name).test;\n        })\n        return function or(x) {\n          for (var i = 0; i < tests.length; i++) {\n            if (tests[i](x)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n    }\n\n    /**\n     * Create a test for all parameters of a signature\n     * @param {Param[]} params\n     * @return {function(args: Array<*>) : boolean}\n     */\n    function compileTests(params) {\n      var tests, test0, test1;\n\n      if (hasRestParam(params)) {\n        // variable arguments like '...number'\n        tests = initial(params).map(compileTest);\n        var varIndex = tests.length;\n        var lastTest = compileTest(last(params));\n        var testRestParam = function (args) {\n          for (var i = varIndex; i < args.length; i++) {\n            if (!lastTest(args[i])) {\n              return false;\n            }\n          }\n          return true;\n        }\n\n        return function testArgs(args) {\n          for (var i = 0; i < tests.length; i++) {\n            if (!tests[i](args[i])) {\n              return false;\n            }\n          }\n          return testRestParam(args) && (args.length >= varIndex + 1);\n        };\n      }\n      else {\n        // no variable arguments\n        if (params.length === 0) {\n          return function testArgs(args) {\n            return args.length === 0;\n          };\n        }\n        else if (params.length === 1) {\n          test0 = compileTest(params[0]);\n          return function testArgs(args) {\n            return test0(args[0]) && args.length === 1;\n          };\n        }\n        else if (params.length === 2) {\n          test0 = compileTest(params[0]);\n          test1 = compileTest(params[1]);\n          return function testArgs(args) {\n            return test0(args[0]) && test1(args[1]) && args.length === 2;\n          };\n        }\n        else { // arguments.length > 2\n          tests = params.map(compileTest);\n          return function testArgs(args) {\n            for (var i = 0; i < tests.length; i++) {\n              if (!tests[i](args[i])) {\n                return false;\n              }\n            }\n            return args.length === tests.length;\n          };\n        }\n      }\n    }\n\n    /**\n     * Find the parameter at a specific index of a signature.\n     * Handles rest parameters.\n     * @param {Signature} signature\n     * @param {number} index\n     * @return {Param | null} Returns the matching parameter when found,\n     *                        null otherwise.\n     */\n    function getParamAtIndex(signature, index) {\n      return index < signature.params.length\n          ? signature.params[index]\n          : hasRestParam(signature.params)\n              ? last(signature.params)\n              : null\n    }\n\n    /**\n     * Get all type names of a parameter\n     * @param {Signature} signature\n     * @param {number} index\n     * @param {boolean} excludeConversions\n     * @return {string[]} Returns an array with type names\n     */\n    function getExpectedTypeNames (signature, index, excludeConversions) {\n      var param = getParamAtIndex(signature, index);\n      var types = param\n          ? excludeConversions\n                  ? param.types.filter(isExactType)\n                  : param.types\n          : [];\n\n      return types.map(getTypeName);\n    }\n\n    /**\n     * Returns the name of a type\n     * @param {Type} type\n     * @return {string} Returns the type name\n     */\n    function getTypeName(type) {\n      return type.name;\n    }\n\n    /**\n     * Test whether a type is an exact type or conversion\n     * @param {Type} type\n     * @return {boolean} Returns true when\n     */\n    function isExactType(type) {\n      return type.conversion === null || type.conversion === undefined;\n    }\n\n    /**\n     * Helper function for creating error messages: create an array with\n     * all available types on a specific argument index.\n     * @param {Signature[]} signatures\n     * @param {number} index\n     * @return {string[]} Returns an array with available types\n     */\n    function mergeExpectedParams(signatures, index) {\n      var typeNames = uniq(flatMap(signatures, function (signature) {\n        return getExpectedTypeNames(signature, index, false);\n      }));\n\n      return (typeNames.indexOf('any') !== -1) ? ['any'] : typeNames;\n    }\n\n    /**\n     * Create\n     * @param {string} name             The name of the function\n     * @param {array.<*>} args          The actual arguments passed to the function\n     * @param {Signature[]} signatures  A list with available signatures\n     * @return {TypeError} Returns a type error with additional data\n     *                     attached to it in the property `data`\n     */\n    function createError(name, args, signatures) {\n      var err, expected;\n      var _name = name || 'unnamed';\n\n      // test for wrong type at some index\n      var matchingSignatures = signatures;\n      var index;\n      for (index = 0; index < args.length; index++) {\n        var nextMatchingDefs = matchingSignatures.filter(function (signature) {\n          var test = compileTest(getParamAtIndex(signature, index));\n          return (index < signature.params.length || hasRestParam(signature.params)) &&\n              test(args[index]);\n        });\n\n        if (nextMatchingDefs.length === 0) {\n          // no matching signatures anymore, throw error \"wrong type\"\n          expected = mergeExpectedParams(matchingSignatures, index);\n          if (expected.length > 0) {\n            var actualType = findTypeName(args[index]);\n\n            err = new TypeError('Unexpected type of argument in function ' + _name +\n                ' (expected: ' + expected.join(' or ') +\n                ', actual: ' + actualType + ', index: ' + index + ')');\n            err.data = {\n              category: 'wrongType',\n              fn: _name,\n              index: index,\n              actual: actualType,\n              expected: expected\n            }\n            return err;\n          }\n        }\n        else {\n          matchingSignatures = nextMatchingDefs;\n        }\n      }\n\n      // test for too few arguments\n      var lengths = matchingSignatures.map(function (signature) {\n        return hasRestParam(signature.params) ? Infinity : signature.params.length;\n      });\n      if (args.length < Math.min.apply(null, lengths)) {\n        expected = mergeExpectedParams(matchingSignatures, index);\n        err = new TypeError('Too few arguments in function ' + _name +\n            ' (expected: ' + expected.join(' or ') +\n            ', index: ' + args.length + ')');\n        err.data = {\n          category: 'tooFewArgs',\n          fn: _name,\n          index: args.length,\n          expected: expected\n        }\n        return err;\n      }\n\n      // test for too many arguments\n      var maxLength = Math.max.apply(null, lengths);\n      if (args.length > maxLength) {\n        err = new TypeError('Too many arguments in function ' + _name +\n            ' (expected: ' + maxLength + ', actual: ' + args.length + ')');\n        err.data = {\n          category: 'tooManyArgs',\n          fn: _name,\n          index: args.length,\n          expectedLength: maxLength\n        }\n        return err;\n      }\n\n      err = new TypeError('Arguments of type \"' + args.join(', ') +\n          '\" do not match any of the defined signatures of function ' + _name + '.');\n      err.data = {\n        category: 'mismatch',\n        actual: args.map(findTypeName)\n      }\n      return err;\n    }\n\n    /**\n     * Find the lowest index of all exact types of a parameter (no conversions)\n     * @param {Param} param\n     * @return {number} Returns the index of the lowest type in typed.types\n     */\n    function getLowestTypeIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].typeIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Find the lowest index of the conversion of all types of the parameter\n     * having a conversion\n     * @param {Param} param\n     * @return {number} Returns the lowest index of the conversions of this type\n     */\n    function getLowestConversionIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (!isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].conversionIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Compare two params\n     * @param {Param} param1\n     * @param {Param} param2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareParams (param1, param2) {\n      var c;\n\n      // compare having a rest parameter or not\n      c = param1.restParam - param2.restParam;\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare having conversions or not\n      c = hasConversions(param1) - hasConversions(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of the types\n      c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of any conversion\n      return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);\n    }\n\n    /**\n     * Compare two signatures\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareSignatures (signature1, signature2) {\n      var len = Math.min(signature1.params.length, signature2.params.length);\n      var i;\n      var c;\n\n      // compare whether the params have conversions at all or not\n      c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions)\n      if (c !== 0) {\n        return c;\n      }\n\n      // next compare whether the params have conversions one by one\n      for (i = 0; i < len; i++) {\n        c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the types of the params one by one\n      for (i = 0; i < len; i++) {\n        c = compareParams(signature1.params[i], signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the number of params\n      return signature1.params.length - signature2.params.length;\n    }\n\n    /**\n     * Get params containing all types that can be converted to the defined types.\n     *\n     * @param {ConversionDef[]} conversions\n     * @param {string[]} typeNames\n     * @return {ConversionDef[]} Returns the conversions that are available\n     *                        for every type (if any)\n     */\n    function filterConversions(conversions, typeNames) {\n      var matches = {};\n\n      conversions.forEach(function (conversion) {\n        if (typeNames.indexOf(conversion.from) === -1 &&\n            typeNames.indexOf(conversion.to) !== -1 &&\n            !matches[conversion.from]) {\n          matches[conversion.from] = conversion;\n        }\n      });\n\n      return Object.keys(matches).map(function (from) {\n        return matches[from];\n      });\n    }\n\n    /**\n     * Preprocess arguments before calling the original function:\n     * - if needed convert the parameters\n     * - in case of rest parameters, move the rest parameters into an Array\n     * @param {Param[]} params\n     * @param {function} fn\n     * @return {function} Returns a wrapped function\n     */\n    function compileArgsPreprocessing(params, fn) {\n      var fnConvert = fn;\n\n      // TODO: can we make this wrapper function smarter/simpler?\n\n      if (params.some(hasConversions)) {\n        var restParam = hasRestParam(params);\n        var compiledConversions = params.map(compileArgConversion)\n\n        fnConvert = function convertArgs() {\n          var args = [];\n          var last = restParam ? arguments.length - 1 : arguments.length;\n          for (var i = 0; i < last; i++) {\n            args[i] = compiledConversions[i](arguments[i]);\n          }\n          if (restParam) {\n            args[last] = arguments[last].map(compiledConversions[last]);\n          }\n\n          return fn.apply(null, args);\n        }\n      }\n\n      var fnPreprocess = fnConvert;\n      if (hasRestParam(params)) {\n        var offset = params.length - 1;\n\n        fnPreprocess = function preprocessRestParams () {\n          return fnConvert.apply(null,\n              slice(arguments, 0, offset).concat([slice(arguments, offset)]));\n        }\n      }\n\n      return fnPreprocess;\n    }\n\n    /**\n     * Compile conversion for a parameter to the right type\n     * @param {Param} param\n     * @return {function} Returns the wrapped function that will convert arguments\n     *\n     */\n    function compileArgConversion(param) {\n      var test0, test1, conversion0, conversion1;\n      var tests = [];\n      var conversions = [];\n\n      param.types.forEach(function (type) {\n        if (type.conversion) {\n          tests.push(findTypeByName(type.conversion.from).test);\n          conversions.push(type.conversion.convert);\n        }\n      });\n\n      // create optimized conversion functions depending on the number of conversions\n      switch (conversions.length) {\n        case 0:\n          return function convertArg(arg) {\n            return arg;\n          }\n\n        case 1:\n          test0 = tests[0]\n          conversion0 = conversions[0];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            return arg;\n          }\n\n        case 2:\n          test0 = tests[0]\n          test1 = tests[1]\n          conversion0 = conversions[0];\n          conversion1 = conversions[1];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            if (test1(arg)) {\n              return conversion1(arg)\n            }\n            return arg;\n          }\n\n        default:\n          return function convertArg(arg) {\n            for (var i = 0; i < conversions.length; i++) {\n              if (tests[i](arg)) {\n                return conversions[i](arg);\n              }\n            }\n            return arg;\n          }\n      }\n    }\n\n    /**\n     * Convert an array with signatures into a map with signatures,\n     * where signatures with union types are split into separate signatures\n     *\n     * Throws an error when there are conflicting types\n     *\n     * @param {Signature[]} signatures\n     * @return {Object.<string, function>}  Returns a map with signatures\n     *                                      as key and the original function\n     *                                      of this signature as value.\n     */\n    function createSignaturesMap(signatures) {\n      var signaturesMap = {};\n      signatures.forEach(function (signature) {\n        if (!signature.params.some(hasConversions)) {\n          splitParams(signature.params, true).forEach(function (params) {\n            signaturesMap[stringifyParams(params)] = signature.fn;\n          });\n        }\n      });\n\n      return signaturesMap;\n    }\n\n    /**\n     * Split params with union types in to separate params.\n     *\n     * For example:\n     *\n     *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\n     *     // returns:\n     *     // [\n     *     //   ['Array', 'string'],\n     *     //   ['Array', 'RegExp'],\n     *     //   ['Object', 'string'],\n     *     //   ['Object', 'RegExp']\n     *     // ]\n     *\n     * @param {Param[]} params\n     * @param {boolean} ignoreConversionTypes\n     * @return {Param[]}\n     */\n    function splitParams(params, ignoreConversionTypes) {\n      function _splitParams(params, index, types) {\n        if (index < params.length) {\n          var param = params[index]\n          var filteredTypes = ignoreConversionTypes\n              ? param.types.filter(isExactType)\n              : param.types;\n          var typeGroups\n\n          if (param.restParam) {\n            // split the types of a rest parameter in two:\n            // one with only exact types, and one with exact types and conversions\n            var exactTypes = filteredTypes.filter(isExactType)\n            typeGroups = exactTypes.length < filteredTypes.length\n                ? [exactTypes, filteredTypes]\n                : [filteredTypes]\n\n          }\n          else {\n            // split all the types of a regular parameter into one type per group\n            typeGroups = filteredTypes.map(function (type) {\n              return [type]\n            })\n          }\n\n          // recurse over the groups with types\n          return flatMap(typeGroups, function (typeGroup) {\n            return _splitParams(params, index + 1, types.concat([typeGroup]));\n          });\n\n        }\n        else {\n          // we've reached the end of the parameters. Now build a new Param\n          var splittedParams = types.map(function (type, typeIndex) {\n            return {\n              types: type,\n              restParam: (typeIndex === params.length - 1) && hasRestParam(params)\n            }\n          });\n\n          return [splittedParams];\n        }\n      }\n\n      return _splitParams(params, 0, []);\n    }\n\n    /**\n     * Test whether two signatures have a conflicting signature\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {boolean} Returns true when the signatures conflict, false otherwise.\n     */\n    function hasConflictingParams(signature1, signature2) {\n      var ii = Math.max(signature1.params.length, signature2.params.length);\n\n      for (var i = 0; i < ii; i++) {\n        var typesNames1 = getExpectedTypeNames(signature1, i, true);\n        var typesNames2 = getExpectedTypeNames(signature2, i, true);\n\n        if (!hasOverlap(typesNames1, typesNames2)) {\n          return false;\n        }\n      }\n\n      var len1 = signature1.params.length;\n      var len2 = signature2.params.length;\n      var restParam1 = hasRestParam(signature1.params);\n      var restParam2 = hasRestParam(signature2.params);\n\n      return restParam1\n          ? restParam2 ? (len1 === len2) : (len2 >= len1)\n          : restParam2 ? (len1 >= len2)  : (len1 === len2)\n    }\n\n    /**\n     * Create a typed function\n     * @param {String} name               The name for the typed function\n     * @param {Object.<string, function>} signaturesMap\n     *                                    An object with one or\n     *                                    multiple signatures as key, and the\n     *                                    function corresponding to the\n     *                                    signature as value.\n     * @return {function}  Returns the created typed function.\n     */\n    function createTypedFunction(name, signaturesMap) {\n      if (Object.keys(signaturesMap).length === 0) {\n        throw new SyntaxError('No signatures provided');\n      }\n\n      // parse the signatures, and check for conflicts\n      var parsedSignatures = [];\n      Object.keys(signaturesMap)\n          .map(function (signature) {\n            return parseSignature(signature, signaturesMap[signature], typed.conversions);\n          })\n          .filter(notNull)\n          .forEach(function (parsedSignature) {\n            // check whether this parameter conflicts with already parsed signatures\n            var conflictingSignature = findInArray(parsedSignatures, function (s) {\n              return hasConflictingParams(s, parsedSignature)\n            });\n            if (conflictingSignature) {\n              throw new TypeError('Conflicting signatures \"' +\n                  stringifyParams(conflictingSignature.params) + '\" and \"' +\n                  stringifyParams(parsedSignature.params) + '\".');\n            }\n\n            parsedSignatures.push(parsedSignature);\n          });\n\n      // split and filter the types of the signatures, and then order them\n      var signatures = flatMap(parsedSignatures, function (parsedSignature) {\n        var params = parsedSignature ? splitParams(parsedSignature.params, false) : []\n\n        return params.map(function (params) {\n          return {\n            params: params,\n            fn: parsedSignature.fn\n          };\n        });\n      }).filter(notNull);\n\n      signatures.sort(compareSignatures);\n\n      // we create a highly optimized checks for the first couple of signatures with max 2 arguments\n      var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);\n      var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);\n      var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);\n      var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);\n      var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);\n      var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);\n      var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;\n\n      // compile the tests\n      var tests = signatures.map(function (signature) {\n        return compileTests(signature.params);\n      });\n\n      var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;\n      var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;\n      var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;\n      var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;\n      var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;\n      var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;\n\n      var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;\n      var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;\n      var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;\n      var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;\n      var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;\n      var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;\n\n      // compile the functions\n      var fns = signatures.map(function(signature) {\n        return compileArgsPreprocessing(signature.params, signature.fn)\n      });\n\n      var fn0 = ok0 ? fns[0] : undef;\n      var fn1 = ok1 ? fns[1] : undef;\n      var fn2 = ok2 ? fns[2] : undef;\n      var fn3 = ok3 ? fns[3] : undef;\n      var fn4 = ok4 ? fns[4] : undef;\n      var fn5 = ok5 ? fns[5] : undef;\n\n      var len0 = ok0 ? signatures[0].params.length : -1;\n      var len1 = ok1 ? signatures[1].params.length : -1;\n      var len2 = ok2 ? signatures[2].params.length : -1;\n      var len3 = ok3 ? signatures[3].params.length : -1;\n      var len4 = ok4 ? signatures[4].params.length : -1;\n      var len5 = ok5 ? signatures[5].params.length : -1;\n\n      // simple and generic, but also slow\n      var iStart = allOk ? 6 : 0;\n      var iEnd = signatures.length;\n      var generic = function generic() {\n        'use strict';\n\n        for (var i = iStart; i < iEnd; i++) {\n          if (tests[i](arguments)) {\n            return fns[i].apply(null, arguments);\n          }\n        }\n\n        throw createError(name, arguments, signatures);\n      }\n\n      // create the typed function\n      // fast, specialized version. Falls back to the slower, generic one if needed\n      var fn = function fn(arg0, arg1) {\n        'use strict';\n\n        if (arguments.length === len0 && test00(arg0) && test01(arg1)) { return fn0.apply(null, arguments); }\n        if (arguments.length === len1 && test10(arg0) && test11(arg1)) { return fn1.apply(null, arguments); }\n        if (arguments.length === len2 && test20(arg0) && test21(arg1)) { return fn2.apply(null, arguments); }\n        if (arguments.length === len3 && test30(arg0) && test31(arg1)) { return fn3.apply(null, arguments); }\n        if (arguments.length === len4 && test40(arg0) && test41(arg1)) { return fn4.apply(null, arguments); }\n        if (arguments.length === len5 && test50(arg0) && test51(arg1)) { return fn5.apply(null, arguments); }\n\n        return generic.apply(null, arguments);\n      }\n\n      // attach name the typed function\n      try {\n        Object.defineProperty(fn, 'name', {value: name});\n      }\n      catch (err) {\n        // old browsers do not support Object.defineProperty and some don't support setting the name property\n        // the function name is not essential for the functioning, it's mostly useful for debugging,\n        // so it's fine to have unnamed functions.\n      }\n\n      // attach signatures to the function\n      fn.signatures = createSignaturesMap(signatures);\n\n      return fn;\n    }\n\n    /**\n     * Test whether a type should be NOT be ignored\n     * @param {string} typeName\n     * @return {boolean}\n     */\n    function notIgnore(typeName) {\n      return typed.ignore.indexOf(typeName) === -1;\n    }\n\n    /**\n     * trim a string\n     * @param {string} str\n     * @return {string}\n     */\n    function trim(str) {\n      return str.trim();\n    }\n\n    /**\n     * Test whether a string is not empty\n     * @param {string} str\n     * @return {boolean}\n     */\n    function notEmpty(str) {\n      return !!str;\n    }\n\n    /**\n     * test whether a value is not strict equal to null\n     * @param {*} value\n     * @return {boolean}\n     */\n    function notNull(value) {\n      return value !== null;\n    }\n\n    /**\n     * Test whether a parameter has no types defined\n     * @param {Param} param\n     * @return {boolean}\n     */\n    function isInvalidParam (param) {\n      return param.types.length === 0;\n    }\n\n    /**\n     * Return all but the last items of an array\n     * @param {Array} arr\n     * @return {Array}\n     */\n    function initial(arr) {\n      return arr.slice(0, arr.length - 1);\n    }\n\n    /**\n     * return the last item of an array\n     * @param {Array} arr\n     * @return {*}\n     */\n    function last(arr) {\n      return arr[arr.length - 1];\n    }\n\n    /**\n     * Slice an array or function Arguments\n     * @param {Array | Arguments | IArguments} arr\n     * @param {number} start\n     * @param {number} [end]\n     * @return {Array}\n     */\n    function slice(arr, start, end) {\n      return Array.prototype.slice.call(arr, start, end);\n    }\n\n    /**\n     * Test whether an array contains some item\n     * @param {Array} array\n     * @param {*} item\n     * @return {boolean} Returns true if array contains item, false if not.\n     */\n    function contains(array, item) {\n      return array.indexOf(item) !== -1;\n    }\n\n    /**\n     * Test whether two arrays have overlapping items\n     * @param {Array} array1\n     * @param {Array} array2\n     * @return {boolean} Returns true when at least one item exists in both arrays\n     */\n    function hasOverlap(array1, array2) {\n      for (var i = 0; i < array1.length; i++) {\n        if (contains(array2, array1[i])) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Return the first item from an array for which test(arr[i]) returns true\n     * @param {Array} arr\n     * @param {function} test\n     * @return {* | undefined} Returns the first matching item\n     *                         or undefined when there is no match\n     */\n    function findInArray(arr, test) {\n      for (var i = 0; i < arr.length; i++) {\n        if (test(arr[i])) {\n          return arr[i];\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * Filter unique items of an array with strings\n     * @param {string[]} arr\n     * @return {string[]}\n     */\n    function uniq(arr) {\n      var entries = {}\n      for (var i = 0; i < arr.length; i++) {\n        entries[arr[i]] = true;\n      }\n      return Object.keys(entries);\n    }\n\n    /**\n     * Flat map the result invoking a callback for every item in an array.\n     * https://gist.github.com/samgiles/762ee337dff48623e729\n     * @param {Array} arr\n     * @param {function} callback\n     * @return {Array}\n     */\n    function flatMap(arr, callback) {\n      return Array.prototype.concat.apply([], arr.map(callback));\n    }\n\n    /**\n     * Retrieve the function name from a set of typed functions,\n     * and check whether the name of all functions match (if given)\n     * @param {function[]} fns\n     */\n    function getName (fns) {\n      var name = '';\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // check whether the names are the same when defined\n        if (fn.signatures && fn.name !== '') {\n          if (name === '') {\n            name = fn.name;\n          }\n          else if (name !== fn.name) {\n            var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');\n            err.data = {\n              actual: fn.name,\n              expected: name\n            };\n            throw err;\n          }\n        }\n      }\n\n      return name;\n    }\n\n    typed = createTypedFunction('typed', {\n      'string, Object': createTypedFunction,\n      'Object': function (signaturesMap) {\n        // find existing name\n        var fns = [];\n        for (var signature in signaturesMap) {\n          if (signaturesMap.hasOwnProperty(signature)) {\n            fns.push(signaturesMap[signature]);\n          }\n        }\n        var name = getName(fns);\n        return createTypedFunction(name, signaturesMap);\n      },\n      '...Function': function (fns) {\n        var err;\n        var name = getName(fns);\n        var signaturesMap = {};\n\n        for (var i = 0; i < fns.length; i++) {\n          var fn = fns[i];\n\n          // test whether this is a typed-function\n          if (!(typeof fn.signatures === 'object')) {\n            err = new TypeError('Function is no typed-function (index: ' + i + ')');\n            err.data = {index: i};\n            throw err;\n          }\n\n          // merge the signatures\n          for (var signature in fn.signatures) {\n            if (fn.signatures.hasOwnProperty(signature)) {\n              if (signaturesMap.hasOwnProperty(signature)) {\n                if (fn.signatures[signature] !== signaturesMap[signature]) {\n                  err = new Error('Signature \"' + signature + '\" is defined twice');\n                  err.data = {signature: signature};\n                  throw err;\n                }\n                // else: both signatures point to the same function, that's fine\n              }\n              else {\n                signaturesMap[signature] = fn.signatures[signature];\n              }\n            }\n          }\n        }\n\n        return createTypedFunction(name, signaturesMap);\n      }\n    });\n\n    typed.create = create;\n    typed.types = _types;\n    typed.conversions = _conversions;\n    typed.ignore = _ignore;\n    typed.convert = convert;\n    typed.find = find;\n\n    // add a type\n    typed.addType = function (type) {\n      if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {\n        throw new TypeError('Object with properties {name: string, test: function} expected');\n      }\n\n      typed.types.push(type);\n    };\n\n    // add a conversion\n    typed.addConversion = function (conversion) {\n      if (!conversion\n          || typeof conversion.from !== 'string'\n          || typeof conversion.to !== 'string'\n          || typeof conversion.convert !== 'function') {\n        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');\n      }\n\n      typed.conversions.push(conversion);\n    };\n\n    return typed;\n  }\n\n  return create();\n}));","module.exports = XMLHttpRequest;\n","module.exports = require('./lib/core/core');","var core = require('./core');\n\n/**\n * ghReleaseInfo.js factory function. Creates a new instance of ghReleaseInfo.js\n *\n */\nfunction create (config) {\n  // create a new ghReleaseInfo.js instance\n  var ghReleaseInfo = core.create(config);\n  ghReleaseInfo.create = create;\n\n  // import data types, functions, constants, expression parser, etc.\n  ghReleaseInfo['import'](require('./lib'));\n\n  return ghReleaseInfo;\n}\n\n// return a new instance of ghReleaseInfo.js\nmodule.exports = create();","var isFactory = require('./../utils/object').isFactory;\r\nvar typedFactory = require('./typed');\r\nvar emitter = require('./../utils/emitter');\r\n\r\nvar importFactory = require('./function/import');\r\nvar configFactory = require('./function/config');\r\n\r\n/**\r\n * Math.js core. Creates a new, empty math.js instance\r\n * @param {Object} [options] Available options:\r\n *                            {number} epsilon\r\n *                              Minimum relative difference between two\r\n *                              compared values, used by all comparison functions.\r\n *                            {string} matrix\r\n *                              A string 'Matrix' (default) or 'Array'.\r\n *                            {string} number\r\n *                              A string 'number' (default), 'BigNumber', or 'Fraction'\r\n *                            {number} precision\r\n *                              The number of significant digits for BigNumbers.\r\n *                              Not applicable for Numbers.\r\n *                            {boolean} predictable\r\n *                              Predictable output type of functions. When true,\r\n *                              output type depends only on the input types. When\r\n *                              false (default), output type can vary depending\r\n *                              on input values. For example `math.sqrt(-4)`\r\n *                              returns `complex('2i')` when predictable is false, and\r\n *                              returns `NaN` when true.\r\n *                            {string} randomSeed\r\n *                              Random seed for seeded pseudo random number generator.\r\n *                              Set to null to randomly seed.\r\n * @returns {Object} Returns a bare-bone math.js instance containing\r\n *                   functions:\r\n *                   - `import` to add new functions\r\n *                   - `config` to change configuration\r\n *                   - `on`, `off`, `once`, `emit` for events\r\n */\r\nexports.create = function create (options) {\r\n  // simple test for ES5 support\r\n  if (typeof Object.create !== 'function') {\r\n    throw new Error('ES5 not supported by this JavaScript engine. ' +\r\n    'Please load the es5-shim and es5-sham library for compatibility.');\r\n  }\r\n\r\n  // cached factories and instances\r\n  var factories = [];\r\n  var instances = [];\r\n\r\n  // create a namespace for the mathjs instance, and attach emitter functions\r\n  var math = emitter.mixin({});\r\n  math.type = {};\r\n  math.expression = {\r\n    transform: {},\r\n    mathWithTransform: {}\r\n  };\r\n\r\n  // create a new typed instance\r\n  math.typed = typedFactory.create(math.type);\r\n\r\n  // create configuration options. These are private\r\n  var _config = {\r\n    // minimum relative difference between two compared values,\r\n    // used by all comparison functions\r\n    epsilon: 1e-12,\r\n\r\n    // type of default matrix output. Choose 'matrix' (default) or 'array'\r\n    matrix: 'Matrix',\r\n\r\n    // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction\r\n    number: 'number',\r\n\r\n    // number of significant digits in BigNumbers\r\n    precision: 64,\r\n\r\n    // predictable output type of functions. When true, output type depends only\r\n    // on the input types. When false (default), output type can vary depending\r\n    // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when\r\n    // predictable is false, and returns `NaN` when true.\r\n    predictable: false,\r\n\r\n    // random seed for seeded pseudo random number generation\r\n    // null = randomly seed\r\n    randomSeed: null\r\n  };\r\n\r\n  /**\r\n   * Load a function or data type from a factory.\r\n   * If the function or data type already exists, the existing instance is\r\n   * returned.\r\n   * @param {{type: string, name: string, factory: Function}} factory\r\n   * @returns {*}\r\n   */\r\n  function load (factory) {\r\n    if (!isFactory(factory)) {\r\n      throw new Error('Factory object with properties `type`, `name`, and `factory` expected');\r\n    }\r\n\r\n    var index = factories.indexOf(factory);\r\n    var instance;\r\n    if (index === -1) {\r\n      // doesn't yet exist\r\n      if (factory.math === true) {\r\n        // pass with math namespace\r\n        instance = factory.factory(math.type, _config, load, math.typed, math);\r\n      }\r\n      else {\r\n        instance = factory.factory(math.type, _config, load, math.typed);\r\n      }\r\n\r\n      // append to the cache\r\n      factories.push(factory);\r\n      instances.push(instance);\r\n    }\r\n    else {\r\n      // already existing function, return the cached instance\r\n      instance = instances[index];\r\n    }\r\n\r\n    return instance;\r\n  }\r\n\r\n  // load the import and config functions\r\n  math['import'] = load(importFactory);\r\n  math['config'] = load(configFactory);\r\n  math.expression.mathWithTransform['config'] = math['config']\r\n\r\n  // apply options\r\n  if (options) {\r\n    math.config(options);\r\n  }\r\n\r\n  return math;\r\n};\r\n","'use strict';\r\n\r\nvar object = require('../../utils/object');\r\n\r\nfunction factory (type, config, load, typed, math) {\r\n  var MATRIX = ['Matrix', 'Array'];                   // valid values for option matrix\r\n  var NUMBER = ['number', 'BigNumber', 'Fraction'];   // valid values for option number\r\n\r\n  /**\r\n   * Set configuration options for math.js, and get current options.\r\n   * Will emit a 'config' event, with arguments (curr, prev, changes).\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.config(config: Object): Object\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.config().number;                // outputs 'number'\r\n   *     math.eval('0.4');                    // outputs number 0.4\r\n   *     math.config({number: 'Fraction'});\r\n   *     math.eval('0.4');                    // outputs Fraction 2/5\r\n   *\r\n   * @param {Object} [options] Available options:\r\n   *                            {number} epsilon\r\n   *                              Minimum relative difference between two\r\n   *                              compared values, used by all comparison functions.\r\n   *                            {string} matrix\r\n   *                              A string 'Matrix' (default) or 'Array'.\r\n   *                            {string} number\r\n   *                              A string 'number' (default), 'BigNumber', or 'Fraction'\r\n   *                            {number} precision\r\n   *                              The number of significant digits for BigNumbers.\r\n   *                              Not applicable for Numbers.\r\n   *                            {string} parenthesis\r\n   *                              How to display parentheses in LaTeX and string\r\n   *                              output.\r\n   *                            {string} randomSeed\r\n   *                              Random seed for seeded pseudo random number generator.\r\n   *                              Set to null to randomly seed.\r\n   * @return {Object} Returns the current configuration\r\n   */\r\n  function _config(options) {\r\n    if (options) {\r\n      var prev = object.map(config, object.clone);\r\n\r\n      // validate some of the options\r\n      validateOption(options, 'matrix', MATRIX);\r\n      validateOption(options, 'number', NUMBER);\r\n\r\n      // merge options\r\n      object.deepExtend(config, options);\r\n\r\n      var curr = object.map(config, object.clone);\r\n\r\n      var changes = object.map(options, object.clone);\r\n\r\n      // emit 'config' event\r\n      math.emit('config', curr, prev, changes);\r\n\r\n      return curr;\r\n    }\r\n    else {\r\n      return object.map(config, object.clone);\r\n    }\r\n  }\r\n\r\n  // attach the valid options to the function so they can be extended\r\n  _config.MATRIX = MATRIX;\r\n  _config.NUMBER = NUMBER;\r\n\r\n  return _config;\r\n}\r\n\r\n/**\r\n * Test whether an Array contains a specific item.\r\n * @param {Array.<string>} array\r\n * @param {string} item\r\n * @return {boolean}\r\n */\r\nfunction contains (array, item) {\r\n  return array.indexOf(item) !== -1;\r\n}\r\n\r\n/**\r\n * Find a string in an array. Case insensitive search\r\n * @param {Array.<string>} array\r\n * @param {string} item\r\n * @return {number} Returns the index when found. Returns -1 when not found\r\n */\r\nfunction findIndex (array, item) {\r\n  return array\r\n      .map(function (i) {\r\n        return i.toLowerCase();\r\n      })\r\n      .indexOf(item.toLowerCase());\r\n}\r\n\r\n/**\r\n * Validate an option\r\n * @param {Object} options         Object with options\r\n * @param {string} name            Name of the option to validate\r\n * @param {Array.<string>} values  Array with valid values for this option\r\n */\r\nfunction validateOption(options, name, values) {\r\n  if (options[name] !== undefined && !contains(values, options[name])) {\r\n    var index = findIndex(values, options[name]);\r\n    if (index !== -1) {\r\n      // right value, wrong casing\r\n      // TODO: lower case values are deprecated since v3, remove this warning some day.\r\n      console.warn('Warning: Wrong casing for configuration option \"' + name + '\", should be \"' + values[index] + '\" instead of \"' + options[name] + '\".');\r\n\r\n      options[name] = values[index]; // change the option to the right casing\r\n    }\r\n    else {\r\n      // unknown value\r\n      console.warn('Warning: Unknown value \"' + options[name] + '\" for configuration option \"' + name + '\". Available options: ' + values.map(JSON.stringify).join(', ') + '.');\r\n    }\r\n  }\r\n}\r\n\r\nexports.name = 'config';\r\nexports.math = true; // request the math namespace as fifth argument\r\nexports.factory = factory;\r\n","'use strict';\r\n\r\nvar lazy = require('../../utils/object').lazy;\r\nvar isFactory = require('../../utils/object').isFactory;\r\nvar traverse = require('../../utils/object').traverse;\r\nvar ArgumentsError = require('../../error/ArgumentsError');\r\n\r\nfunction factory (type, config, load, typed, math) {\r\n  /**\r\n   * Import functions from an object or a module\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.import(object)\r\n   *    math.import(object, options)\r\n   *\r\n   * Where:\r\n   *\r\n   * - `object: Object`\r\n   *   An object with functions to be imported.\r\n   * - `options: Object` An object with import options. Available options:\r\n   *   - `override: boolean`\r\n   *     If true, existing functions will be overwritten. False by default.\r\n   *   - `silent: boolean`\r\n   *     If true, the function will not throw errors on duplicates or invalid\r\n   *     types. False by default.\r\n   *   - `wrap: boolean`\r\n   *     If true, the functions will be wrapped in a wrapper function\r\n   *     which converts data types like Matrix to primitive data types like Array.\r\n   *     The wrapper is needed when extending math.js with libraries which do not\r\n   *     support these data type. False by default.\r\n   *\r\n   * Examples:\r\n   *\r\n   *    // define new functions and variables\r\n   *    math.import({\r\n   *      myvalue: 42,\r\n   *      hello: function (name) {\r\n   *        return 'hello, ' + name + '!';\r\n   *      }\r\n   *    });\r\n   *\r\n   *    // use the imported function and variable\r\n   *    math.myvalue * 2;               // 84\r\n   *    math.hello('user');             // 'hello, user!'\r\n   *\r\n   *    // import the npm module 'numbers'\r\n   *    // (must be installed first with `npm install numbers`)\r\n   *    math.import(require('numbers'), {wrap: true});\r\n   *\r\n   *    math.fibonacci(7); // returns 13\r\n   *\r\n   * @param {Object | Array} object   Object with functions to be imported.\r\n   * @param {Object} [options]        Import options.\r\n   */\r\n  function math_import(object, options) {\r\n    var num = arguments.length;\r\n    if (num !== 1 && num !== 2) {\r\n      throw new ArgumentsError('import', num, 1, 2);\r\n    }\r\n\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n\r\n    if (isFactory(object)) {\r\n      _importFactory(object, options);\r\n    }\r\n    // TODO: allow a typed-function with name too\r\n    else if (Array.isArray(object)) {\r\n      object.forEach(function (entry) {\r\n        math_import(entry, options);\r\n      });\r\n    }\r\n    else if (typeof object === 'object') {\r\n      // a map with functions\r\n      for (var name in object) {\r\n        if (object.hasOwnProperty(name)) {\r\n          var value = object[name];\r\n          if (isSupportedType(value)) {\r\n            _import(name, value, options);\r\n          }\r\n          else if (isFactory(object)) {\r\n            _importFactory(object, options);\r\n          }\r\n          else {\r\n            math_import(value, options);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      if (!options.silent) {\r\n        throw new TypeError('Factory, Object, or Array expected');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a property to the math namespace and create a chain proxy for it.\r\n   * @param {string} name\r\n   * @param {*} value\r\n   * @param {Object} options  See import for a description of the options\r\n   * @private\r\n   */\r\n  function _import(name, value, options) {\r\n    // TODO: refactor this function, it's to complicated and contains duplicate code\r\n    if (options.wrap && typeof value === 'function') {\r\n      // create a wrapper around the function\r\n      value = _wrap(value);\r\n    }\r\n\r\n    if (isTypedFunction(math[name]) && isTypedFunction(value)) {\r\n      if (options.override) {\r\n        // give the typed function the right name\r\n        value = typed(name, value.signatures);\r\n      }\r\n      else {\r\n        // merge the existing and typed function\r\n        value = typed(math[name], value);\r\n      }\r\n\r\n      math[name] = value;\r\n      _importTransform(name, value);\r\n      math.emit('import', name, function resolver() {\r\n        return value;\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (math[name] === undefined || options.override) {\r\n      math[name] = value;\r\n      _importTransform(name, value);\r\n      math.emit('import', name, function resolver() {\r\n        return value;\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (!options.silent) {\r\n      throw new Error('Cannot import \"' + name + '\": already exists');\r\n    }\r\n  }\r\n\r\n  function _importTransform (name, value) {\r\n    if (value && typeof value.transform === 'function') {\r\n      math.expression.transform[name] = value.transform;\r\n      if (allowedInExpressions(name)) {\r\n        math.expression.mathWithTransform[name] = value.transform\r\n      }\r\n    }\r\n    else {\r\n      // remove existing transform\r\n      delete math.expression.transform[name]\r\n      if (allowedInExpressions(name)) {\r\n        math.expression.mathWithTransform[name] = value\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a wrapper a round an function which converts the arguments\r\n   * to their primitive values (like convert a Matrix to Array)\r\n   * @param {Function} fn\r\n   * @return {Function} Returns the wrapped function\r\n   * @private\r\n   */\r\n  function _wrap (fn) {\r\n    var wrapper = function wrapper () {\r\n      var args = [];\r\n      for (var i = 0, len = arguments.length; i < len; i++) {\r\n        var arg = arguments[i];\r\n        args[i] = arg && arg.valueOf();\r\n      }\r\n      return fn.apply(math, args);\r\n    };\r\n\r\n    if (fn.transform) {\r\n      wrapper.transform = fn.transform;\r\n    }\r\n\r\n    return wrapper;\r\n  }\r\n\r\n  /**\r\n   * Import an instance of a factory into math.js\r\n   * @param {{factory: Function, name: string, path: string, math: boolean}} factory\r\n   * @param {Object} options  See import for a description of the options\r\n   * @private\r\n   */\r\n  function _importFactory(factory, options) {\r\n    if (typeof factory.name === 'string') {\r\n      var name = factory.name;\r\n      var existingTransform = name in math.expression.transform\r\n      var namespace = factory.path ? traverse(math, factory.path) : math;\r\n      var existing = namespace.hasOwnProperty(name) ? namespace[name] : undefined;\r\n\r\n      var resolver = function () {\r\n        var instance = load(factory);\r\n        if (instance && typeof instance.transform === 'function') {\r\n          throw new Error('Transforms cannot be attached to factory functions. ' +\r\n              'Please create a separate function for it with exports.path=\"expression.transform\"');\r\n        }\r\n\r\n        if (isTypedFunction(existing) && isTypedFunction(instance)) {\r\n          if (options.override) {\r\n            // replace the existing typed function (nothing to do)\r\n          }\r\n          else {\r\n            // merge the existing and new typed function\r\n            instance = typed(existing, instance);\r\n          }\r\n\r\n          return instance;\r\n        }\r\n\r\n        if (existing === undefined || options.override) {\r\n          return instance;\r\n        }\r\n\r\n        if (!options.silent) {\r\n          throw new Error('Cannot import \"' + name + '\": already exists');\r\n        }\r\n      };\r\n\r\n      if (factory.lazy !== false) {\r\n        lazy(namespace, name, resolver);\r\n\r\n        if (!existingTransform) {\r\n          if (factory.path === 'expression.transform' || factoryAllowedInExpressions(factory)) {\r\n            lazy(math.expression.mathWithTransform, name, resolver);\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        namespace[name] = resolver();\r\n\r\n        if (!existingTransform) {\r\n          if (factory.path === 'expression.transform' || factoryAllowedInExpressions(factory)) {\r\n            math.expression.mathWithTransform[name] = resolver();\r\n          }\r\n        }\r\n      }\r\n\r\n      math.emit('import', name, resolver, factory.path);\r\n    }\r\n    else {\r\n      // unnamed factory.\r\n      // no lazy loading\r\n      load(factory);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check whether given object is a type which can be imported\r\n   * @param {Function | number | string | boolean | null | Unit | Complex} object\r\n   * @return {boolean}\r\n   * @private\r\n   */\r\n  function isSupportedType(object) {\r\n    return typeof object === 'function'\r\n        || typeof object === 'number'\r\n        || typeof object === 'string'\r\n        || typeof object === 'boolean'\r\n        || object === null\r\n        || (object && type.isUnit(object))\r\n        || (object && type.isComplex(object))\r\n        || (object && type.isBigNumber(object))\r\n        || (object && type.isFraction(object))\r\n        || (object && type.isMatrix(object))\r\n        || (object && Array.isArray(object))\r\n  }\r\n\r\n  /**\r\n   * Test whether a given thing is a typed-function\r\n   * @param {*} fn\r\n   * @return {boolean} Returns true when `fn` is a typed-function\r\n   */\r\n  function isTypedFunction (fn) {\r\n    return typeof fn === 'function' && typeof fn.signatures === 'object';\r\n  }\r\n\r\n  function allowedInExpressions (name) {\r\n    return !unsafe.hasOwnProperty(name);\r\n  }\r\n\r\n  function factoryAllowedInExpressions (factory) {\r\n    return factory.path === undefined && !unsafe.hasOwnProperty(factory.name);\r\n  }\r\n\r\n  // namespaces and functions not available in the parser for safety reasons\r\n  var unsafe = {\r\n    'expression': true,\r\n    'type': true,\r\n    'docs': true,\r\n    'error': true,\r\n    'json': true,\r\n    'chain': true // chain method not supported. Note that there is a unit chain too.\r\n  };\r\n\r\n  return math_import;\r\n}\r\n\r\nexports.math = true; // request access to the math namespace as 5th argument of the factory function\r\nexports.name = 'import';\r\nexports.factory = factory;\r\nexports.lazy = true;\r\n","var typedFunction = require('typed-function');\r\nvar digits = require('./../utils/number').digits;\r\nvar isBigNumber = require('./../utils/bignumber/isBigNumber');\r\nvar isMatrix = require('./../utils/collection/isMatrix');\r\n\r\n// returns a new instance of typed-function\r\nvar createTyped = function () {\r\n  // initially, return the original instance of typed-function\r\n  // consecutively, return a new instance from typed.create.\r\n  createTyped = typedFunction.create;\r\n  return typedFunction;\r\n};\r\n\r\n/**\r\n * Factory function for creating a new typed instance\r\n * @param {Object} type   Object with data types like Complex and BigNumber\r\n * @returns {Function}\r\n */\r\nexports.create = function create(type) {\r\n  // TODO: typed-function must be able to silently ignore signatures with unknown data types\r\n\r\n  // type checks for all known types\r\n  //\r\n  // note that:\r\n  //\r\n  // - check by duck-typing on a property like `isUnit`, instead of checking instanceof.\r\n  //   instanceof cannot be used because that would not allow to pass data from\r\n  //   one instance of math.js to another since each has it's own instance of Unit.\r\n  // - check the `isUnit` property via the constructor, so there will be no\r\n  //   matches for \"fake\" instances like plain objects with a property `isUnit`.\r\n  //   That is important for security reasons.\r\n  // - It must not be possible to override the type checks used internally,\r\n  //   for security reasons, so these functions are not exposed in the expression\r\n  //   parser.\r\n  type.isNumber = function (x) { return typeof x === 'number' };\r\n  type.isComplex = function (x) { return type.Complex && x instanceof type.Complex || false };\r\n  type.isBigNumber = isBigNumber;\r\n  type.isFraction = function (x) { return type.Fraction && x instanceof type.Fraction || false };\r\n  type.isUnit = function (x) { return x && x.constructor.prototype.isUnit || false };\r\n  type.isString = function (x) { return typeof x === 'string' };\r\n  type.isArray = Array.isArray;\r\n  type.isMatrix = isMatrix;\r\n  type.isDenseMatrix = function (x) { return x && x.isDenseMatrix && x.constructor.prototype.isMatrix || false };\r\n  type.isSparseMatrix = function (x) { return x && x.isSparseMatrix && x.constructor.prototype.isMatrix || false };\r\n  type.isRange = function (x) { return x && x.constructor.prototype.isRange || false };\r\n  type.isIndex = function (x) { return x && x.constructor.prototype.isIndex || false };\r\n  type.isBoolean = function (x) { return typeof x === 'boolean' };\r\n  type.isResultSet = function (x) { return x && x.constructor.prototype.isResultSet || false };\r\n  type.isHelp = function (x) { return x && x.constructor.prototype.isHelp || false };\r\n  type.isFunction = function (x) { return typeof x === 'function'};\r\n  type.isDate = function (x) { return x instanceof Date };\r\n  type.isRegExp = function (x) { return x instanceof RegExp };\r\n  type.isObject = function (x) {\r\n    return typeof x === 'object' &&\r\n        x.constructor === Object &&\r\n        !type.isComplex(x) &&\r\n        !type.isFraction(x)\r\n  };\r\n  type.isNull = function (x) { return x === null };\r\n  type.isUndefined = function (x) { return x === undefined };\r\n\r\n  type.isAccessorNode = function (x) { return x && x.isAccessorNode && x.constructor.prototype.isNode || false };\r\n  type.isArrayNode = function (x) { return x && x.isArrayNode && x.constructor.prototype.isNode || false };\r\n  type.isAssignmentNode = function (x) { return x && x.isAssignmentNode && x.constructor.prototype.isNode || false };\r\n  type.isBlockNode = function (x) { return x && x.isBlockNode && x.constructor.prototype.isNode || false };\r\n  type.isConditionalNode = function (x) { return x && x.isConditionalNode && x.constructor.prototype.isNode || false };\r\n  type.isConstantNode = function (x) { return x && x.isConstantNode && x.constructor.prototype.isNode || false };\r\n  type.isFunctionAssignmentNode = function (x) { return x && x.isFunctionAssignmentNode && x.constructor.prototype.isNode || false };\r\n  type.isFunctionNode = function (x) { return x && x.isFunctionNode && x.constructor.prototype.isNode || false };\r\n  type.isIndexNode = function (x) { return x && x.isIndexNode && x.constructor.prototype.isNode || false };\r\n  type.isNode = function (x) { return x && x.isNode && x.constructor.prototype.isNode || false };\r\n  type.isObjectNode = function (x) { return x && x.isObjectNode && x.constructor.prototype.isNode || false };\r\n  type.isOperatorNode = function (x) { return x && x.isOperatorNode && x.constructor.prototype.isNode || false };\r\n  type.isParenthesisNode = function (x) { return x && x.isParenthesisNode && x.constructor.prototype.isNode || false };\r\n  type.isRangeNode = function (x) { return x && x.isRangeNode && x.constructor.prototype.isNode || false };\r\n  type.isSymbolNode = function (x) { return x && x.isSymbolNode && x.constructor.prototype.isNode || false };\r\n\r\n  type.isChain = function (x) { return x && x.constructor.prototype.isChain || false };\r\n\r\n  // get a new instance of typed-function\r\n  var typed = createTyped();\r\n\r\n  // define all types. The order of the types determines in which order function\r\n  // arguments are type-checked (so for performance it's important to put the\r\n  // most used types first).\r\n  typed.types = [\r\n    { name: 'number',          test: type.isNumber },\r\n    { name: 'Complex',         test: type.isComplex },\r\n    { name: 'BigNumber',       test: type.isBigNumber },\r\n    { name: 'Fraction',        test: type.isFraction },\r\n    { name: 'Unit',            test: type.isUnit },\r\n    { name: 'string',          test: type.isString },\r\n    { name: 'Array',           test: type.isArray },\r\n    { name: 'Matrix',          test: type.isMatrix },\r\n    { name: 'DenseMatrix',     test: type.isDenseMatrix },\r\n    { name: 'SparseMatrix',    test: type.isSparseMatrix },\r\n    { name: 'Range',           test: type.isRange },\r\n    { name: 'Index',           test: type.isIndex },\r\n    { name: 'boolean',         test: type.isBoolean },\r\n    { name: 'ResultSet',       test: type.isResultSet },\r\n    { name: 'Help',            test: type.isHelp },\r\n    { name: 'function',        test: type.isFunction },\r\n    { name: 'Date',            test: type.isDate },\r\n    { name: 'RegExp',          test: type.isRegExp },\r\n    { name: 'null',            test: type.isNull },\r\n    { name: 'undefined',       test: type.isUndefined },\r\n\r\n    { name: 'OperatorNode',    test: type.isOperatorNode },\r\n    { name: 'ConstantNode',    test: type.isConstantNode },\r\n    { name: 'SymbolNode',      test: type.isSymbolNode },\r\n    { name: 'ParenthesisNode', test: type.isParenthesisNode },\r\n    { name: 'FunctionNode',    test: type.isFunctionNode },\r\n    { name: 'FunctionAssignmentNode',    test: type.isFunctionAssignmentNode },\r\n    { name: 'ArrayNode',                 test: type.isArrayNode },\r\n    { name: 'AssignmentNode',            test: type.isAssignmentNode },\r\n    { name: 'BlockNode',                 test: type.isBlockNode },\r\n    { name: 'ConditionalNode',           test: type.isConditionalNode },\r\n    { name: 'IndexNode',                 test: type.isIndexNode },\r\n    { name: 'RangeNode',                 test: type.isRangeNode },\r\n    { name: 'Node',                      test: type.isNode },\r\n\r\n    { name: 'Object',          test: type.isObject } // order 'Object' last, it's a tricky one\r\n  ];\r\n\r\n  // TODO: add conversion from BigNumber to number?\r\n  typed.conversions = [\r\n    {\r\n      from: 'number',\r\n      to: 'BigNumber',\r\n      convert: function (x) {\r\n        // note: conversion from number to BigNumber can fail if x has >15 digits\r\n        if (digits(x) > 15) {\r\n          throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' +\r\n          '(value: ' + x + '). ' +\r\n          'Use function bignumber(x) to convert to BigNumber.');\r\n        }\r\n        return new type.BigNumber(x);\r\n      }\r\n    }, {\r\n      from: 'number',\r\n      to: 'Complex',\r\n      convert: function (x) {\r\n        return new type.Complex(x, 0);\r\n      }\r\n    }, {\r\n      from: 'number',\r\n      to: 'string',\r\n      convert: function (x) {\r\n        return x + '';\r\n      }\r\n    }, {\r\n      from: 'BigNumber',\r\n      to: 'Complex',\r\n      convert: function (x) {\r\n        return new type.Complex(x.toNumber(), 0);\r\n      }\r\n    }, {\r\n      from: 'Fraction',\r\n      to: 'BigNumber',\r\n      convert: function (x) {\r\n        throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' +\r\n            'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');\r\n      }\r\n    }, {\r\n      from: 'Fraction',\r\n      to: 'Complex',\r\n      convert: function (x) {\r\n        return new type.Complex(x.valueOf(), 0);\r\n      }\r\n    }, {\r\n      from: 'number',\r\n      to: 'Fraction',\r\n      convert: function (x) {\r\n        var f = new type.Fraction(x);\r\n        if (f.valueOf() !== x) {\r\n          throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' +\r\n              '(value: ' + x + '). ' +\r\n              'Use function fraction(x) to convert to Fraction.');\r\n        }\r\n        return new type.Fraction(x);\r\n      }\r\n    }, {\r\n    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`\r\n    //  from: 'Fraction',\r\n    //  to: 'number',\r\n    //  convert: function (x) {\r\n    //    return x.valueOf();\r\n    //  }\r\n    //}, {\r\n      from: 'string',\r\n      to: 'number',\r\n      convert: function (x) {\r\n        var n = Number(x);\r\n        if (isNaN(n)) {\r\n          throw new Error('Cannot convert \"' + x + '\" to a number');\r\n        }\r\n        return n;\r\n      }\r\n    }, {\r\n      from: 'string',\r\n      to: 'BigNumber',\r\n      convert: function (x) {\r\n        try {\r\n          return new type.BigNumber(x);\r\n        }\r\n        catch (err) {\r\n          throw new Error('Cannot convert \"' + x + '\" to BigNumber');\r\n        }\r\n      }\r\n    }, {\r\n      from: 'string',\r\n      to: 'Fraction',\r\n      convert: function (x) {\r\n        try {\r\n          return new type.Fraction(x);\r\n        }\r\n        catch (err) {\r\n          throw new Error('Cannot convert \"' + x + '\" to Fraction');\r\n        }\r\n      }\r\n    }, {\r\n      from: 'string',\r\n      to: 'Complex',\r\n      convert: function (x) {\r\n        try {\r\n          return new type.Complex(x);\r\n        }\r\n        catch (err) {\r\n          throw new Error('Cannot convert \"' + x + '\" to Complex');\r\n        }\r\n      }\r\n    }, {\r\n      from: 'boolean',\r\n      to: 'number',\r\n      convert: function (x) {\r\n        return +x;\r\n      }\r\n    }, {\r\n      from: 'boolean',\r\n      to: 'BigNumber',\r\n      convert: function (x) {\r\n        return new type.BigNumber(+x);\r\n      }\r\n    }, {\r\n      from: 'boolean',\r\n      to: 'Fraction',\r\n      convert: function (x) {\r\n        return new type.Fraction(+x);\r\n      }\r\n    }, {\r\n      from: 'boolean',\r\n      to: 'string',\r\n      convert: function (x) {\r\n        return +x;\r\n      }\r\n    }, {\r\n      from: 'Array',\r\n      to: 'Matrix',\r\n      convert: function (array) {\r\n        return new type.DenseMatrix(array);\r\n      }\r\n    }, {\r\n      from: 'Matrix',\r\n      to: 'Array',\r\n      convert: function (matrix) {\r\n        return matrix.valueOf();\r\n      }\r\n    }\r\n  ];\r\n\r\n  return typed;\r\n};\r\n","'use strict';\r\n\r\n/**\r\n * Create a syntax error with the message:\r\n *     'Wrong number of arguments in function <fn> (<count> provided, <min>-<max> expected)'\r\n * @param {string} fn     Function name\r\n * @param {number} count  Actual argument count\r\n * @param {number} min    Minimum required argument count\r\n * @param {number} [max]  Maximum required argument count\r\n * @extends Error\r\n */\r\nfunction ArgumentsError(fn, count, min, max) {\r\n  if (!(this instanceof ArgumentsError)) {\r\n    throw new SyntaxError('Constructor must be called with the new operator');\r\n  }\r\n\r\n  this.fn = fn;\r\n  this.count = count;\r\n  this.min = min;\r\n  this.max = max;\r\n\r\n  this.message = 'Wrong number of arguments in function ' + fn +\r\n      ' (' + count + ' provided, ' +\r\n      min + ((max != undefined) ? ('-' + max) : '') + ' expected)';\r\n\r\n  this.stack = (new Error()).stack;\r\n}\r\n\r\nArgumentsError.prototype = new Error();\r\nArgumentsError.prototype.constructor = Error;\r\nArgumentsError.prototype.name = 'ArgumentsError';\r\nArgumentsError.prototype.isArgumentsError = true;\r\n\r\nmodule.exports = ArgumentsError;\r\n","'use strict';\r\n\r\n/**\r\n * Create a range error with the message:\r\n *     'Dimension mismatch (<actual size> != <expected size>)'\r\n * @param {number | number[]} actual        The actual size\r\n * @param {number | number[]} expected      The expected size\r\n * @param {string} [relation='!=']          Optional relation between actual\r\n *                                          and expected size: '!=', '<', etc.\r\n * @extends RangeError\r\n */\r\nfunction DimensionError(actual, expected, relation) {\r\n  if (!(this instanceof DimensionError)) {\r\n    throw new SyntaxError('Constructor must be called with the new operator');\r\n  }\r\n\r\n  this.actual   = actual;\r\n  this.expected = expected;\r\n  this.relation = relation;\r\n\r\n  this.message = 'Dimension mismatch (' +\r\n      (Array.isArray(actual) ? ('[' + actual.join(', ') + ']') : actual) +\r\n      ' ' + (this.relation || '!=') + ' ' +\r\n      (Array.isArray(expected) ? ('[' + expected.join(', ') + ']') : expected) +\r\n      ')';\r\n\r\n  this.stack = (new Error()).stack;\r\n}\r\n\r\nDimensionError.prototype = new RangeError();\r\nDimensionError.prototype.constructor = RangeError;\r\nDimensionError.prototype.name = 'DimensionError';\r\nDimensionError.prototype.isDimensionError = true;\r\n\r\nmodule.exports = DimensionError;\r\n","'use strict';\r\n\r\n/**\r\n * Create a range error with the message:\r\n *     'Index out of range (index < min)'\r\n *     'Index out of range (index < max)'\r\n *\r\n * @param {number} index     The actual index\r\n * @param {number} [min=0]   Minimum index (included)\r\n * @param {number} [max]     Maximum index (excluded)\r\n * @extends RangeError\r\n */\r\nfunction IndexError(index, min, max) {\r\n  if (!(this instanceof IndexError)) {\r\n    throw new SyntaxError('Constructor must be called with the new operator');\r\n  }\r\n\r\n  this.index = index;\r\n  if (arguments.length < 3) {\r\n    this.min = 0;\r\n    this.max = min;\r\n  }\r\n  else {\r\n    this.min = min;\r\n    this.max = max;\r\n  }\r\n\r\n  if (this.min !== undefined && this.index < this.min) {\r\n    this.message = 'Index out of range (' + this.index + ' < ' + this.min + ')';\r\n  }\r\n  else if (this.max !== undefined && this.index >= this.max) {\r\n    this.message = 'Index out of range (' + this.index + ' > ' + (this.max - 1) + ')';\r\n  }\r\n  else {\r\n    this.message = 'Index out of range (' + this.index + ')';\r\n  }\r\n\r\n  this.stack = (new Error()).stack;\r\n}\r\n\r\nIndexError.prototype = new RangeError();\r\nIndexError.prototype.constructor = RangeError;\r\nIndexError.prototype.name = 'IndexError';\r\nIndexError.prototype.isIndexError = true;\r\n\r\nmodule.exports = IndexError;\r\n","'use strict';\r\n\r\nvar ArgumentsError = require('./ArgumentsError');\r\nvar DimensionError = require('./DimensionError');\r\nvar IndexError = require('./IndexError');\r\n\r\nmodule.exports = [\r\n  {\r\n    name: 'ArgumentsError', path: 'error',\r\n    factory: function () {\r\n      return ArgumentsError;\r\n    }\r\n  },\r\n  {\r\n    name: 'DimensionError',\r\n    path: 'error',\r\n    factory: function () {\r\n      return DimensionError;\r\n    }\r\n  },\r\n  {\r\n    name: 'IndexError',\r\n    path: 'error',\r\n    factory: function () {\r\n      return IndexError;\r\n    }\r\n  }\r\n];\r\n\r\n// TODO: implement an InvalidValueError?\r\n","'use strict';\r\n\r\nvar object= require('../utils/object');\r\n\r\nfunction factory (type, config, load, typed) {\r\n  /**\r\n   * Clone an object.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.clone(x)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.clone(3.5);                   // returns number 3.5\r\n   *    math.clone(math.complex('2-4i'); // returns Complex 2 - 4i\r\n   *    math.clone(math.unit(45, 'deg'));  // returns Unit 45 deg\r\n   *    math.clone([[1, 2], [3, 4]]);      // returns Array [[1, 2], [3, 4]]\r\n   *    math.clone(\"hello world\");         // returns string \"hello world\"\r\n   *\r\n   * @param {*} x   Object to be cloned\r\n   * @return {*} A clone of object x\r\n   */\r\n  var clone = typed('clone', {\r\n    'any': object.clone\r\n  });\r\n\r\n  clone.toTex = undefined; // use default template\r\n\r\n  return clone;\r\n}\r\n\r\nexports.name = 'clone';\r\nexports.factory = factory;\r\n","'use strict';\r\nvar XMLHttpRequest = require(\"xhr2\");\r\n\r\nfunction loadJSON(path, success, error)\r\n{\r\n  var xhr = new XMLHttpRequest();\r\n  xhr.onreadystatechange = function()\r\n  {\r\n    if (xhr.readyState === XMLHttpRequest.DONE) {\r\n      if (xhr.status === 200) {\r\n        if (success)\r\n          success(JSON.parse(xhr.responseText));\r\n      } else {\r\n        if (error)\r\n          error(xhr);\r\n      }\r\n    }\r\n  };\r\n  xhr.open(\"GET\", path, true);\r\n  xhr.send();\r\n}\r\n\r\nfunction GetLatestGitHubReleaseInfo(repo) {\r\n  return new Promise(resolve => {\r\n    loadJSON(\"https://api.github.com/repos/\"+repo+\"/releases/latest\", function(release) {\r\n      let tuppleList = [];\r\n      let IsRelease = (url) => {\r\n        return !url.endsWith(\"sig\") && !url.endsWith(\"asc\");\r\n      };\r\n      let oneHour = 60 * 60 * 1000;\r\n      let oneDay = 24 * oneHour;\r\n      release.assets.filter(asset => IsRelease(asset.browser_download_url))\r\n        .forEach((casset) => {\r\n          let dateDiff = new Date() - new Date(casset.updated_at);\r\n          let timeAgo;\r\n          if (dateDiff < oneDay)\r\n            timeAgo = (dateDiff / oneHour).toFixed(1) + \" hours ago\";\r\n          else\r\n            timeAgo = (dateDiff / oneDay).toFixed(1) + \" days ago\";\r\n          tuppleList.push({count: casset.download_count, url: casset.browser_download_url, timeAgo: timeAgo})\r\n        })\r\n\r\n      let returnStructVar = {\r\n        releaseName: release.name,\r\n        downloadList: tuppleList\r\n      }\r\n      resolve(returnStructVar);\r\n    },\r\n    function(xhr) {\r\n      throw new URIError(\"Error loading JSON!\");\r\n    });\r\n  }, 2000);\r\n}\r\n\r\nfunction factory (type, config, load, typed) {\r\n  /**\r\n   * Clone an object.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.clone(x)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.clone(3.5);                   // returns number 3.5\r\n   *    math.clone(math.complex('2-4i'); // returns Complex 2 - 4i\r\n   *    math.clone(math.unit(45, 'deg'));  // returns Unit 45 deg\r\n   *    math.clone([[1, 2], [3, 4]]);      // returns Array [[1, 2], [3, 4]]\r\n   *    math.clone(\"hello world\");         // returns string \"hello world\"\r\n   *\r\n   * @param {*} x   Object to be cloned\r\n   * @return {*} A clone of object x\r\n   */\r\n  var get = typed('get', {\r\n    'string': GetLatestGitHubReleaseInfo,\r\n  });\r\n\r\n  get.toTex = {1: '\\\\left|${args[0]}\\\\right|'};\r\n\r\n  return get;\r\n}\r\n\r\nexports.name = 'get';\r\nexports.factory = factory;","module.exports = [\r\n  require('./clone'),\r\n  require('./get')\r\n];\r\n","module.exports = [\r\n  // require('./type'),        // data types (Matrix, Complex, Unit, ...)\r\n  // require('./constants'),   // constants\r\n  // require('./expression'),  // expression parsing\r\n  require('./function'),    // functions\r\n  require('./json'),        // serialization utility (math.json.reviver)\r\n  require('./error')        // errors\r\n];\r\n","module.exports = [\r\n  require('./reviver')\r\n];\r\n","'use strict';\r\n\r\nfunction factory (type, config, load, typed, math) {\r\n  /**\r\n   * Instantiate mathjs data types from their JSON representation\r\n   * @param {string} key\r\n   * @param {*} value\r\n   * @returns {*} Returns the revived object\r\n   */\r\n  return function reviver(key, value) {\r\n    var constructor = type[value && value.mathjs] ||\r\n        (math.expression && math.expression.node[value && value.mathjs]);\r\n    // TODO: instead of checking math.expression.node, expose all Node classes on math.type too\r\n\r\n    if (constructor && typeof constructor.fromJSON === 'function') {\r\n      return constructor.fromJSON(value);\r\n    }\r\n\r\n    return value;\r\n  }\r\n}\r\n\r\nexports.name = 'reviver';\r\nexports.path = 'json';\r\nexports.factory = factory;\r\nexports.math = true; // request the math namespace as fifth argument\r\n","/**\r\n * Test whether a value is a BigNumber\r\n * @param {*} x\r\n * @return {boolean}\r\n */\r\nmodule.exports = function isBigNumber(x) {\r\n  return x && x.constructor.prototype.isBigNumber || false\r\n}\r\n","'use strict';\r\n\r\n/**\r\n * Test whether a value is a Matrix\r\n * @param {*} x\r\n * @returns {boolean} returns true with input is a Matrix\r\n *                    (like a DenseMatrix or SparseMatrix)\r\n */\r\nmodule.exports = function isMatrix (x) {\r\n  return x && x.constructor.prototype.isMatrix || false;\r\n};\r\n","var Emitter = require('tiny-emitter');\r\n\r\n/**\r\n * Extend given object with emitter functions `on`, `off`, `once`, `emit`\r\n * @param {Object} obj\r\n * @return {Object} obj\r\n */\r\nexports.mixin = function (obj) {\r\n  // create event emitter\r\n  var emitter = new Emitter();\r\n\r\n  // bind methods to obj (we don't want to expose the emitter.e Array...)\r\n  obj.on   = emitter.on.bind(emitter);\r\n  obj.off  = emitter.off.bind(emitter);\r\n  obj.once = emitter.once.bind(emitter);\r\n  obj.emit = emitter.emit.bind(emitter);\r\n\r\n  return obj;\r\n};\r\n","'use strict';\r\n\r\n/**\r\n * @typedef {{sign: '+' | '-' | '', coefficients: number[], exponent: number}} SplitValue\r\n */\r\n\r\n/**\r\n * Test whether value is a number\r\n * @param {*} value\r\n * @return {boolean} isNumber\r\n */\r\nexports.isNumber = function(value) {\r\n  return typeof value === 'number';\r\n};\r\n\r\n/**\r\n * Check if a number is integer\r\n * @param {number | boolean} value\r\n * @return {boolean} isInteger\r\n */\r\nexports.isInteger = function(value) {\r\n  return isFinite(value)\r\n      ? (value == Math.round(value))\r\n      : false;\r\n  // Note: we use ==, not ===, as we can have Booleans as well\r\n};\r\n\r\n/**\r\n * Calculate the sign of a number\r\n * @param {number} x\r\n * @returns {*}\r\n */\r\nexports.sign = Math.sign || function(x) {\r\n  if (x > 0) {\r\n    return 1;\r\n  }\r\n  else if (x < 0) {\r\n    return -1;\r\n  }\r\n  else {\r\n    return 0;\r\n  }\r\n};\r\n\r\n/**\r\n * Convert a number to a formatted string representation.\r\n *\r\n * Syntax:\r\n *\r\n *    format(value)\r\n *    format(value, options)\r\n *    format(value, precision)\r\n *    format(value, fn)\r\n *\r\n * Where:\r\n *\r\n *    {number} value   The value to be formatted\r\n *    {Object} options An object with formatting options. Available options:\r\n *                     {string} notation\r\n *                         Number notation. Choose from:\r\n *                         'fixed'          Always use regular number notation.\r\n *                                          For example '123.40' and '14000000'\r\n *                         'exponential'    Always use exponential notation.\r\n *                                          For example '1.234e+2' and '1.4e+7'\r\n *                         'engineering'    Always use engineering notation.\r\n *                                          For example '123.4e+0' and '14.0e+6'\r\n *                         'auto' (default) Regular number notation for numbers\r\n *                                          having an absolute value between\r\n *                                          `lowerExp` and `upperExp` bounds, and \r\n *                                          uses exponential notation elsewhere.\r\n *                                          Lower bound is included, upper bound\r\n *                                          is excluded.\r\n *                                          For example '123.4' and '1.4e7'.\r\n *                     {number} precision   A number between 0 and 16 to round\r\n *                                          the digits of the number.\r\n *                                          In case of notations 'exponential' and\r\n *                                          'auto', `precision` defines the total\r\n *                                          number of significant digits returned.\r\n *                                          In case of notation 'fixed',\r\n *                                          `precision` defines the number of\r\n *                                          significant digits after the decimal \r\n *                                          point.\r\n *                                          `precision` is undefined by default,\r\n *                                          not rounding any digits.\r\n *                     {number} lowerExp    Exponent determining the lower boundary\r\n *                                          for formatting a value with an exponent\r\n *                                          when `notation='auto`. \r\n *                                          Default value is `-3`.\r\n *                     {number} upperExp    Exponent determining the upper boundary\r\n *                                          for formatting a value with an exponent\r\n *                                          when `notation='auto`. \r\n *                                          Default value is `5`.\r\n *    {Function} fn    A custom formatting function. Can be used to override the\r\n *                     built-in notations. Function `fn` is called with `value` as\r\n *                     parameter and must return a string. Is useful for example to\r\n *                     format all values inside a matrix in a particular way.\r\n *\r\n * Examples:\r\n *\r\n *    format(6.4);                                        // '6.4'\r\n *    format(1240000);                                    // '1.24e6'\r\n *    format(1/3);                                        // '0.3333333333333333'\r\n *    format(1/3, 3);                                     // '0.333'\r\n *    format(21385, 2);                                   // '21000'\r\n *    format(12.071, {notation: 'fixed'});                // '12'\r\n *    format(2.3,    {notation: 'fixed', precision: 2});  // '2.30'\r\n *    format(52.8,   {notation: 'exponential'});          // '5.28e+1'\r\n *    format(12345678, {notation: 'engineering'});        // '12.345678e+6'\r\n *\r\n * @param {number} value\r\n * @param {Object | Function | number} [options]\r\n * @return {string} str The formatted value\r\n */\r\nexports.format = function(value, options) {\r\n  if (typeof options === 'function') {\r\n    // handle format(value, fn)\r\n    return options(value);\r\n  }\r\n\r\n  // handle special cases\r\n  if (value === Infinity) {\r\n    return 'Infinity';\r\n  }\r\n  else if (value === -Infinity) {\r\n    return '-Infinity';\r\n  }\r\n  else if (isNaN(value)) {\r\n    return 'NaN';\r\n  }\r\n\r\n  // default values for options\r\n  var notation = 'auto';\r\n  var precision = undefined;\r\n\r\n  if (options) {\r\n    // determine notation from options\r\n    if (options.notation) {\r\n      notation = options.notation;\r\n    }\r\n\r\n    // determine precision from options\r\n    if (exports.isNumber(options)) {\r\n      precision = options;\r\n    }\r\n    else if (options.precision) {\r\n      precision = options.precision;\r\n    }\r\n  }\r\n\r\n  // handle the various notations\r\n  switch (notation) {\r\n    case 'fixed':\r\n      return exports.toFixed(value, precision);\r\n\r\n    case 'exponential':\r\n      return exports.toExponential(value, precision);\r\n\r\n    case 'engineering':\r\n      return exports.toEngineering(value, precision);\r\n\r\n    case 'auto':\r\n      // TODO: clean up some day. Deprecated since: 2018-01-24\r\n      // @deprecated upper and lower are replaced with upperExp and lowerExp since v4.0.0\r\n      if (options && options.exponential && (options.exponential.lower !== undefined || options.exponential.upper !== undefined)) {\r\n        var fixedOptions = Object.assign({}, options);\r\n        fixedOptions.exponential = undefined;\r\n        if (options.exponential.lower !== undefined) {\r\n          fixedOptions.lowerExp = Math.round(Math.log(options.exponential.lower) / Math.LN10);\r\n        }\r\n        if (options.exponential.upper !== undefined) {\r\n          fixedOptions.upperExp = Math.round(Math.log(options.exponential.upper) / Math.LN10);\r\n        }\r\n\r\n        console.warn('Deprecation warning: Formatting options exponential.lower and exponential.upper ' + \r\n            '(minimum and maximum value) ' +\r\n            'are replaced with exponential.lowerExp and exponential.upperExp ' + \r\n            '(minimum and maximum exponent) since version 4.0.0. ' + \r\n            'Replace ' + JSON.stringify(options) + ' with ' + JSON.stringify(fixedOptions));\r\n\r\n        return exports.toPrecision(value, precision, fixedOptions);\r\n      }\r\n\r\n      return exports\r\n          .toPrecision(value, precision, options && options)\r\n\r\n          // remove trailing zeros after the decimal point\r\n          .replace(/((\\.\\d*?)(0+))($|e)/, function () {\r\n            var digits = arguments[2];\r\n            var e = arguments[4];\r\n            return (digits !== '.') ? digits + e : e;\r\n          });\r\n\r\n    default:\r\n      throw new Error('Unknown notation \"' + notation + '\". ' +\r\n          'Choose \"auto\", \"exponential\", or \"fixed\".');\r\n  }\r\n};\r\n\r\n/**\r\n * Split a number into sign, coefficients, and exponent\r\n * @param {number | string} value\r\n * @return {SplitValue}\r\n *              Returns an object containing sign, coefficients, and exponent\r\n */\r\nexports.splitNumber = function (value) {\r\n  // parse the input value\r\n  var match = String(value).toLowerCase().match(/^0*?(-?)(\\d+\\.?\\d*)(e([+-]?\\d+))?$/);\r\n  if (!match) {\r\n    throw new SyntaxError('Invalid number ' + value);\r\n  }\r\n\r\n  var sign         = match[1];\r\n  var digits       = match[2];\r\n  var exponent     = parseFloat(match[4] || '0');\r\n\r\n  var dot = digits.indexOf('.');\r\n  exponent += (dot !== -1) ? (dot - 1) : (digits.length - 1);\r\n\r\n  var coefficients = digits\r\n      .replace('.', '')  // remove the dot (must be removed before removing leading zeros)\r\n      .replace(/^0*/, function (zeros) {\r\n        // remove leading zeros, add their count to the exponent\r\n        exponent -= zeros.length;\r\n        return '';\r\n      })\r\n      .replace(/0*$/, '') // remove trailing zeros\r\n      .split('')\r\n      .map(function (d) {\r\n        return parseInt(d);\r\n      });\r\n\r\n  if (coefficients.length === 0) {\r\n    coefficients.push(0);\r\n    exponent++;\r\n  }\r\n\r\n  return {\r\n    sign: sign,\r\n    coefficients: coefficients,\r\n    exponent: exponent\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * Format a number in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'\r\n * @param {number | string} value\r\n * @param {number} [precision=0]        Optional number of decimals after the\r\n *                                      decimal point. Zero by default.\r\n */\r\nexports.toEngineering = function (value, precision) {\r\n  if (isNaN(value) || !isFinite(value)) {\r\n    return String(value);\r\n  }\r\n  \r\n  var rounded = exports.roundDigits(exports.splitNumber(value), precision);\r\n\r\n  var e = rounded.exponent;\r\n  var c = rounded.coefficients;\r\n\r\n  // find nearest lower multiple of 3 for exponent\r\n  var newExp = e % 3 === 0 ? e : (e < 0 ? (e - 3) - (e % 3) : e - (e % 3));\r\n\r\n  // concatenate coefficients with necessary zeros\r\n  var significandsDiff = e >= 0 ? e : Math.abs(newExp);\r\n\r\n  // add zeros if necessary (for ex: 1e+8)\r\n  if (c.length - 1 < significandsDiff) c = c.concat(zeros(significandsDiff - (c.length - 1)));\r\n\r\n  // find difference in exponents\r\n  var expDiff = Math.abs(e - newExp);\r\n\r\n  var decimalIdx = 1;\r\n\r\n  // push decimal index over by expDiff times\r\n  while (--expDiff >= 0) decimalIdx++;\r\n\r\n  // if all coefficient values are zero after the decimal point, don't add a decimal value.\r\n  // otherwise concat with the rest of the coefficients\r\n  var decimals = c.slice(decimalIdx).join('');\r\n  var decimalVal = decimals.match(/[1-9]/) ? ('.' + decimals) : '';\r\n\r\n  var str = c.slice(0, decimalIdx).join('') +\r\n      decimalVal +\r\n      'e' + (e >= 0 ? '+' : '') + newExp.toString();\r\n  return rounded.sign + str;\r\n};\r\n\r\n/**\r\n * Format a number with fixed notation.\r\n * @param {number | string} value\r\n * @param {number} [precision=undefined]  Optional number of decimals after the\r\n *                                        decimal point. null by default.\r\n */\r\nexports.toFixed = function (value, precision) {\r\n  if (isNaN(value) || !isFinite(value)) {\r\n    return String(value);\r\n  }\r\n\r\n  var splitValue = exports.splitNumber(value)\r\n  var rounded = (typeof precision === 'number')\r\n      ? exports.roundDigits(splitValue, splitValue.exponent + 1 + precision)\r\n      : splitValue;\r\n  var c = rounded.coefficients;\r\n  var p = rounded.exponent + 1; // exponent may have changed\r\n\r\n  // append zeros if needed\r\n  var pp = p + (precision || 0);\r\n  if (c.length < pp) {\r\n    c = c.concat(zeros(pp - c.length));\r\n  }\r\n\r\n  // prepend zeros if needed\r\n  if (p < 0) {\r\n    c = zeros(-p + 1).concat(c);\r\n    p = 1;\r\n  }\r\n\r\n  // insert a dot if needed\r\n  if (p < c.length) {\r\n    c.splice(p, 0, (p === 0) ? '0.' : '.');\r\n  }\r\n\r\n  return rounded.sign + c.join('');\r\n};\r\n\r\n/**\r\n * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'\r\n * @param {number | string} value\r\n * @param {number} [precision]  Number of digits in formatted output.\r\n *                              If not provided, the maximum available digits\r\n *                              is used.\r\n */\r\nexports.toExponential = function (value, precision) {\r\n  if (isNaN(value) || !isFinite(value)) {\r\n    return String(value);\r\n  }\r\n\r\n  // round if needed, else create a clone\r\n  var split = exports.splitNumber(value)\r\n  var rounded = precision ? exports.roundDigits(split, precision) : split;\r\n  var c = rounded.coefficients;\r\n  var e = rounded.exponent;\r\n\r\n  // append zeros if needed\r\n  if (c.length < precision) {\r\n    c = c.concat(zeros(precision - c.length));\r\n  }\r\n\r\n  // format as `C.CCCe+EEE` or `C.CCCe-EEE`\r\n  var first = c.shift();\r\n  return rounded.sign + first + (c.length > 0 ? ('.' + c.join('')) : '') +\r\n      'e' + (e >= 0 ? '+' : '') + e;\r\n}\r\n\r\n/**\r\n * Format a number with a certain precision\r\n * @param {number | string} value\r\n * @param {number} [precision=undefined] Optional number of digits.\r\n * @param {{lowerExp: number | undefined, upperExp: number | undefined}} [options]\r\n *                                       By default:\r\n *                                         lowerExp = -3 (incl)\r\n *                                         upper = +5 (excl)\r\n * @return {string}\r\n */\r\nexports.toPrecision = function (value, precision, options) {\r\n  if (isNaN(value) || !isFinite(value)) {\r\n    return String(value);\r\n  }\r\n\r\n  // determine lower and upper bound for exponential notation.\r\n  var lowerExp = (options && options.lowerExp !== undefined) ? options.lowerExp : -3;\r\n  var upperExp = (options && options.upperExp !== undefined) ? options.upperExp : 5;\r\n\r\n  var split = exports.splitNumber(value)\r\n  if (split.exponent < lowerExp || split.exponent >= upperExp) {\r\n    // exponential notation\r\n    return exports.toExponential(value, precision);\r\n  }\r\n  else {\r\n    var rounded = precision ? exports.roundDigits(split, precision) : split;\r\n    var c = rounded.coefficients;\r\n    var e = rounded.exponent;\r\n\r\n    // append trailing zeros\r\n    if (c.length < precision) {\r\n      c = c.concat(zeros(precision - c.length));\r\n    }\r\n\r\n    // append trailing zeros\r\n    // TODO: simplify the next statement\r\n    c = c.concat(zeros(e - c.length + 1 +\r\n        (c.length < precision ? precision - c.length : 0)));\r\n\r\n    // prepend zeros\r\n    c = zeros(-e).concat(c);\r\n\r\n    var dot = e > 0 ? e : 0;\r\n    if (dot < c.length - 1) {\r\n      c.splice(dot + 1, 0, '.');\r\n    }\r\n\r\n    return rounded.sign + c.join('');\r\n  }\r\n}\r\n\r\n/**\r\n * Round the number of digits of a number *\r\n * @param {SplitValue} split       A value split with .splitNumber(value)\r\n * @param {number} precision  A positive integer\r\n * @return {SplitValue}\r\n *              Returns an object containing sign, coefficients, and exponent\r\n *              with rounded digits\r\n */\r\nexports.roundDigits = function (split, precision) {\r\n  // create a clone\r\n  var rounded = {\r\n    sign: split.sign,\r\n    coefficients: split.coefficients,\r\n    exponent: split.exponent\r\n  }\r\n  var c = rounded.coefficients;\r\n\r\n  // prepend zeros if needed\r\n  while (precision <= 0) {\r\n    c.unshift(0);\r\n    rounded.exponent++;\r\n    precision++;\r\n  }\r\n\r\n  if (c.length > precision) {\r\n    var removed = c.splice(precision, c.length - precision);\r\n\r\n    if (removed[0] >= 5) {\r\n      var i = precision - 1;\r\n      c[i]++;\r\n      while (c[i] === 10) {\r\n        c.pop();\r\n        if (i === 0) {\r\n          c.unshift(0);\r\n          rounded.exponent++;\r\n          i++;\r\n        }\r\n        i--;\r\n        c[i]++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return rounded;\r\n};\r\n\r\n/**\r\n * Create an array filled with zeros.\r\n * @param {number} length\r\n * @return {Array}\r\n */\r\nfunction zeros(length) {\r\n  var arr = [];\r\n  for (var i = 0; i < length; i++) {\r\n    arr.push(0);\r\n  }\r\n  return arr;\r\n}\r\n\r\n/**\r\n * Count the number of significant digits of a number.\r\n *\r\n * For example:\r\n *   2.34 returns 3\r\n *   0.0034 returns 2\r\n *   120.5e+30 returns 4\r\n *\r\n * @param {number} value\r\n * @return {number} digits   Number of significant digits\r\n */\r\nexports.digits = function(value) {\r\n  return value\r\n      .toExponential()\r\n      .replace(/e.*$/, '')          // remove exponential notation\r\n      .replace( /^0\\.?0*|\\./, '')   // remove decimal point and leading zeros\r\n      .length\r\n};\r\n\r\n/**\r\n * Minimum number added to one that makes the result different than one\r\n */\r\nexports.DBL_EPSILON = Number.EPSILON || 2.2204460492503130808472633361816E-16;\r\n\r\n/**\r\n * Compares two floating point numbers.\r\n * @param {number} x          First value to compare\r\n * @param {number} y          Second value to compare\r\n * @param {number} [epsilon]  The maximum relative difference between x and y\r\n *                            If epsilon is undefined or null, the function will\r\n *                            test whether x and y are exactly equal.\r\n * @return {boolean} whether the two numbers are nearly equal\r\n*/\r\nexports.nearlyEqual = function(x, y, epsilon) {\r\n  // if epsilon is null or undefined, test whether x and y are exactly equal\r\n  if (epsilon == null) {\r\n    return x == y;\r\n  }\r\n\r\n  // use \"==\" operator, handles infinities\r\n  if (x == y) {\r\n    return true;\r\n  }\r\n\r\n  // NaN\r\n  if (isNaN(x) || isNaN(y)) {\r\n    return false;\r\n  }\r\n\r\n  // at this point x and y should be finite\r\n  if(isFinite(x) && isFinite(y)) {\r\n    // check numbers are very close, needed when comparing numbers near zero\r\n    var diff = Math.abs(x - y);\r\n    if (diff < exports.DBL_EPSILON) {\r\n      return true;\r\n    }\r\n    else {\r\n      // use relative error\r\n      return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;\r\n    }\r\n  }\r\n\r\n  // Infinite and Number or negative Infinite and positive Infinite cases\r\n  return false;\r\n};\r\n","'use strict';\r\n\r\nvar isBigNumber = require('./bignumber/isBigNumber');\r\n\r\n/**\r\n * Clone an object\r\n *\r\n *     clone(x)\r\n *\r\n * Can clone any primitive type, array, and object.\r\n * If x has a function clone, this function will be invoked to clone the object.\r\n *\r\n * @param {*} x\r\n * @return {*} clone\r\n */\r\nexports.clone = function clone(x) {\r\n  var type = typeof x;\r\n\r\n  // immutable primitive types\r\n  if (type === 'number' || type === 'string' || type === 'boolean' ||\r\n      x === null || x === undefined) {\r\n    return x;\r\n  }\r\n\r\n  // use clone function of the object when available\r\n  if (typeof x.clone === 'function') {\r\n    return x.clone();\r\n  }\r\n\r\n  // array\r\n  if (Array.isArray(x)) {\r\n    return x.map(function (value) {\r\n      return clone(value);\r\n    });\r\n  }\r\n\r\n  if (x instanceof Number)    return new Number(x.valueOf());\r\n  if (x instanceof String)    return new String(x.valueOf());\r\n  if (x instanceof Boolean)   return new Boolean(x.valueOf());\r\n  if (x instanceof Date)      return new Date(x.valueOf());\r\n  if (isBigNumber(x))         return x; // bignumbers are immutable\r\n  if (x instanceof RegExp)  throw new TypeError('Cannot clone ' + x);  // TODO: clone a RegExp\r\n\r\n  // object\r\n  return exports.map(x, clone);\r\n};\r\n\r\n/**\r\n * Apply map to all properties of an object\r\n * @param {Object} object\r\n * @param {function} callback\r\n * @return {Object} Returns a copy of the object with mapped properties\r\n */\r\nexports.map = function(object, callback) {\r\n  var clone = {};\r\n\r\n  for (var key in object) {\r\n    if (exports.hasOwnProperty(object, key)) {\r\n      clone[key] = callback(object[key]);\r\n    }\r\n  }\r\n\r\n  return clone;\r\n}\r\n\r\n/**\r\n * Extend object a with the properties of object b\r\n * @param {Object} a\r\n * @param {Object} b\r\n * @return {Object} a\r\n */\r\nexports.extend = function(a, b) {\r\n  for (var prop in b) {\r\n    if (exports.hasOwnProperty(b, prop)) {\r\n      a[prop] = b[prop];\r\n    }\r\n  }\r\n  return a;\r\n};\r\n\r\n/**\r\n * Deep extend an object a with the properties of object b\r\n * @param {Object} a\r\n * @param {Object} b\r\n * @returns {Object}\r\n */\r\nexports.deepExtend = function deepExtend (a, b) {\r\n  // TODO: add support for Arrays to deepExtend\r\n  if (Array.isArray(b)) {\r\n    throw new TypeError('Arrays are not supported by deepExtend');\r\n  }\r\n\r\n  for (var prop in b) {\r\n    if (exports.hasOwnProperty(b, prop)) {\r\n      if (b[prop] && b[prop].constructor === Object) {\r\n        if (a[prop] === undefined) {\r\n          a[prop] = {};\r\n        }\r\n        if (a[prop].constructor === Object) {\r\n          deepExtend(a[prop], b[prop]);\r\n        }\r\n        else {\r\n          a[prop] = b[prop];\r\n        }\r\n      } else if (Array.isArray(b[prop])) {\r\n        throw new TypeError('Arrays are not supported by deepExtend');\r\n      } else {\r\n        a[prop] = b[prop];\r\n      }\r\n    }\r\n  }\r\n  return a;\r\n};\r\n\r\n/**\r\n * Deep test equality of all fields in two pairs of arrays or objects.\r\n * @param {Array | Object} a\r\n * @param {Array | Object} b\r\n * @returns {boolean}\r\n */\r\nexports.deepEqual = function deepEqual (a, b) {\r\n  var prop, i, len;\r\n  if (Array.isArray(a)) {\r\n    if (!Array.isArray(b)) {\r\n      return false;\r\n    }\r\n\r\n    if (a.length != b.length) {\r\n      return false;\r\n    }\r\n\r\n    for (i = 0, len = a.length; i < len; i++) {\r\n      if (!exports.deepEqual(a[i], b[i])) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  else if (a instanceof Object) {\r\n    if (Array.isArray(b) || !(b instanceof Object)) {\r\n      return false;\r\n    }\r\n\r\n    for (prop in a) {\r\n      //noinspection JSUnfilteredForInLoop\r\n      if (!exports.deepEqual(a[prop], b[prop])) {\r\n        return false;\r\n      }\r\n    }\r\n    for (prop in b) {\r\n      //noinspection JSUnfilteredForInLoop\r\n      if (!exports.deepEqual(a[prop], b[prop])) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  else {\r\n    return (typeof a === typeof b) && (a == b);\r\n  }\r\n};\r\n\r\n/**\r\n * Test whether the current JavaScript engine supports Object.defineProperty\r\n * @returns {boolean} returns true if supported\r\n */\r\nexports.canDefineProperty = function () {\r\n  // test needed for broken IE8 implementation\r\n  try {\r\n    if (Object.defineProperty) {\r\n      Object.defineProperty({}, 'x', { get: function () {} });\r\n      return true;\r\n    }\r\n  } catch (e) {}\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Attach a lazy loading property to a constant.\r\n * The given function `fn` is called once when the property is first requested.\r\n * On older browsers (<IE8), the function will fall back to direct evaluation\r\n * of the properties value.\r\n * @param {Object} object   Object where to add the property\r\n * @param {string} prop     Property name\r\n * @param {Function} fn     Function returning the property value. Called\r\n *                          without arguments.\r\n */\r\nexports.lazy = function (object, prop, fn) {\r\n  if (exports.canDefineProperty()) {\r\n    var _uninitialized = true;\r\n    var _value;\r\n    Object.defineProperty(object, prop, {\r\n      get: function () {\r\n        if (_uninitialized) {\r\n          _value = fn();\r\n          _uninitialized = false;\r\n        }\r\n        return _value;\r\n      },\r\n\r\n      set: function (value) {\r\n        _value = value;\r\n        _uninitialized = false;\r\n      },\r\n\r\n      configurable: true,\r\n      enumerable: true\r\n    });\r\n  }\r\n  else {\r\n    // fall back to immediate evaluation\r\n    object[prop] = fn();\r\n  }\r\n};\r\n\r\n/**\r\n * Traverse a path into an object.\r\n * When a namespace is missing, it will be created\r\n * @param {Object} object\r\n * @param {string} path   A dot separated string like 'name.space'\r\n * @return {Object} Returns the object at the end of the path\r\n */\r\nexports.traverse = function(object, path) {\r\n  var obj = object;\r\n\r\n  if (path) {\r\n    var names = path.split('.');\r\n    for (var i = 0; i < names.length; i++) {\r\n      var name = names[i];\r\n      if (!(name in obj)) {\r\n        obj[name] = {};\r\n      }\r\n      obj = obj[name];\r\n    }\r\n  }\r\n\r\n  return obj;\r\n};\r\n\r\n/**\r\n * A safe hasOwnProperty\r\n * @param {Object} object\r\n * @param {string} property\r\n */\r\nexports.hasOwnProperty = function (object, property) {\r\n  return object && Object.hasOwnProperty.call(object, property);\r\n}\r\n\r\n/**\r\n * Test whether an object is a factory. a factory has fields:\r\n *\r\n * - factory: function (type: Object, config: Object, load: function, typed: function [, math: Object])   (required)\r\n * - name: string (optional)\r\n * - path: string    A dot separated path (optional)\r\n * - math: boolean   If true (false by default), the math namespace is passed\r\n *                   as fifth argument of the factory function\r\n *\r\n * @param {*} object\r\n * @returns {boolean}\r\n */\r\nexports.isFactory = function (object) {\r\n  return object && typeof object.factory === 'function';\r\n};\r\n"],"sourceRoot":""}